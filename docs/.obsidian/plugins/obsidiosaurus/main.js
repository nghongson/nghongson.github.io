/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/gm/lib/options.js
var require_options = __commonJS({
  "node_modules/gm/lib/options.js"(exports, module2) {
    module2.exports = exports = function(proto) {
      proto._options = {};
      proto.options = function setOptions(options) {
        var keys = Object.keys(options), i = keys.length, key;
        while (i--) {
          key = keys[i];
          this._options[key] = options[key];
        }
        return this;
      };
    };
  }
});

// node_modules/gm/lib/getters.js
var require_getters = __commonJS({
  "node_modules/gm/lib/getters.js"(exports, module2) {
    module2.exports = function(gm2) {
      var proto = gm2.prototype;
      const IDENTIFYING = 1;
      const IDENTIFIED = 2;
      var map = {
        "format": { key: "format", format: "%m ", helper: "Format" },
        "depth": { key: "depth", format: "%q" },
        "filesize": { key: "Filesize", format: "%b" },
        "size": { key: "size", format: "%wx%h ", helper: "Geometry" },
        "color": { key: "color", format: "%k", helper: "Colors" },
        "orientation": { key: "Orientation", format: "%[EXIF:Orientation]", helper: "Orientation" },
        "res": { key: "Resolution", verbose: true }
      };
      Object.keys(map).forEach(function(getter) {
        proto[getter] = function(opts, callback) {
          if (!callback)
            callback = opts, opts = {};
          if (!callback)
            return this;
          var val = map[getter], key = val.key, self2 = this;
          if (self2.data[key]) {
            callback.call(self2, null, self2.data[key]);
            return self2;
          }
          self2.on(getter, callback);
          self2.bufferStream = !!opts.bufferStream;
          if (val.verbose) {
            self2.identify(opts, function(err, stdout, stderr, cmd) {
              if (err) {
                self2.emit(getter, err, self2.data[key], stdout, stderr, cmd);
              } else {
                self2.emit(getter, err, self2.data[key]);
              }
            });
            return self2;
          }
          var args = makeArgs(self2, val);
          self2._exec(args, function(err, stdout, stderr, cmd) {
            if (err) {
              self2.emit(getter, err, self2.data[key], stdout, stderr, cmd);
              return;
            }
            var result = (stdout || "").trim();
            if (val.helper in helper) {
              helper[val.helper](self2.data, result);
            } else {
              self2.data[key] = result;
            }
            self2.emit(getter, err, self2.data[key]);
          });
          return self2;
        };
      });
      proto.identify = function identify(opts, callback) {
        if (typeof opts === "string") {
          opts = {
            format: opts
          };
        }
        if (!callback)
          callback = opts, opts = {};
        if (!callback)
          return this;
        if (opts && opts.format)
          return identifyPattern.call(this, opts, callback);
        var self2 = this;
        if (IDENTIFIED === self2._identifyState) {
          callback.call(self2, null, self2.data);
          return self2;
        }
        self2.on("identify", callback);
        if (IDENTIFYING === self2._identifyState) {
          return self2;
        }
        self2._identifyState = IDENTIFYING;
        self2.bufferStream = !!opts.bufferStream;
        var args = makeArgs(self2, { verbose: true });
        self2._exec(args, function(err, stdout, stderr, cmd) {
          if (err) {
            self2.emit("identify", err, self2.data, stdout, stderr, cmd);
            return;
          }
          err = parse2(stdout, self2);
          if (err) {
            self2.emit("identify", err, self2.data, stdout, stderr, cmd);
            return;
          }
          self2.data.path = self2.source;
          self2.emit("identify", null, self2.data);
          self2._identifyState = IDENTIFIED;
        });
        return self2;
      };
      function identifyPattern(opts, callback) {
        var self2 = this;
        self2.bufferStream = !!opts.bufferStream;
        var args = makeArgs(self2, opts);
        self2._exec(args, function(err, stdout, stderr, cmd) {
          if (err) {
            return callback.call(self2, err, void 0, stdout, stderr, cmd);
          }
          callback.call(self2, err, (stdout || "").trim());
        });
        return self2;
      }
      function parse2(stdout, self2) {
        var parts = (stdout || "").trim().replace(/\r\n|\r/g, "\n").split("\n");
        parts.shift();
        try {
          var len = parts.length, rgx1 = /^( *)(.+?): (.*)$/, rgx2 = /^( *)(.+?):$/, out = { indent: {} }, level = null, lastkey, i = 0, res, o;
          for (; i < len; ++i) {
            res = rgx1.exec(parts[i]) || rgx2.exec(parts[i]);
            if (!res)
              continue;
            var indent = res[1].length, key = res[2] ? res[2].trim() : "";
            if ("Image" == key || "Warning" == key)
              continue;
            var val = res[3] ? res[3].trim() : null;
            if (null === level) {
              level = indent;
              o = out.root = out.indent[level] = self2.data;
            } else if (indent < level) {
              if (!(indent in out.indent)) {
                continue;
              }
              o = out.indent[indent];
            } else if (indent > level) {
              out.indent[level] = o;
              o = o[lastkey] = {};
            }
            level = indent;
            if (val) {
              if (o.hasOwnProperty(key)) {
                if (!Array.isArray(o[key])) {
                  var tmp = o[key];
                  o[key] = [tmp];
                }
                o[key].push(val);
              } else {
                o[key] = val;
              }
              if (key in helper) {
                helper[key](o, val);
              }
            }
            lastkey = key;
          }
        } catch (err) {
          err.message = err.message + "\n\n  Identify stdout:\n  " + stdout;
          return err;
        }
      }
      function makeArgs(self2, val) {
        var args = [
          "identify",
          "-ping"
        ];
        if (val.format) {
          args.push("-format", val.format);
        }
        if (val.verbose) {
          args.push("-verbose");
        }
        args = args.concat(self2.src());
        return args;
      }
      var orientations = {
        "1": "TopLeft",
        "2": "TopRight",
        "3": "BottomRight",
        "4": "BottomLeft",
        "5": "LeftTop",
        "6": "RightTop",
        "7": "RightBottom",
        "8": "LeftBottom"
      };
      var helper = gm2.identifyHelpers = {};
      helper.Geometry = function Geometry(o, val) {
        var split = val.split(" ").shift().split("x");
        var width = parseInt(split[0], 10);
        var height = parseInt(split[1], 10);
        if (o.size && o.size.width && o.size.height) {
          if (width > o.size.width)
            o.size.width = width;
          if (height > o.size.height)
            o.size.height = height;
        } else {
          o.size = {
            width,
            height
          };
        }
      };
      helper.Format = function Format(o, val) {
        o.format = val.split(" ")[0];
      };
      helper.Depth = function Depth(o, val) {
        o.depth = parseInt(val, 10);
      };
      helper.Colors = function Colors(o, val) {
        o.color = parseInt(val, 10);
      };
      helper.Orientation = function Orientation(o, val) {
        if (val in orientations) {
          o["Profile-EXIF"] || (o["Profile-EXIF"] = {});
          o["Profile-EXIF"].Orientation = val;
          o.Orientation = orientations[val];
        } else {
          o.Orientation = val || "Unknown";
        }
      };
    };
  }
});

// node_modules/gm/lib/utils.js
var require_utils = __commonJS({
  "node_modules/gm/lib/utils.js"(exports) {
    exports.escape = function escape(arg) {
      return '"' + String(arg).trim().replace(/"/g, '\\"') + '"';
    };
    exports.unescape = function escape(arg) {
      return String(arg).trim().replace(/"/g, "");
    };
    exports.argsToArray = function(args) {
      var arr = [];
      for (var i = 0; i <= arguments.length; i++) {
        if ("undefined" != typeof arguments[i])
          arr.push(arguments[i]);
      }
      return arr;
    };
    exports.isUtil = function(v) {
      var ty = "object";
      switch (Object.prototype.toString.call(v)) {
        case "[object String]":
          ty = "String";
          break;
        case "[object Array]":
          ty = "Array";
          break;
        case "[object Boolean]":
          ty = "Boolean";
          break;
      }
      return ty;
    };
  }
});

// node_modules/gm/lib/args.js
var require_args = __commonJS({
  "node_modules/gm/lib/args.js"(exports, module2) {
    var argsToArray = require_utils().argsToArray;
    var isUtil = require_utils().isUtil;
    module2.exports = function(proto) {
      proto.selectFrame = function(frame) {
        if (typeof frame === "number")
          this.sourceFrames = "[" + frame + "]";
        return this;
      };
      proto.command = proto.subCommand = function subCommand(name) {
        this._subCommand = name;
        return this;
      };
      proto.adjoin = function adjoin() {
        return this.out("-adjoin");
      };
      proto.affine = function affine(matrix) {
        return this.out("-affine", matrix);
      };
      proto.alpha = function alpha(type) {
        if (!this._options.imageMagick)
          return new Error("Method -alpha is not supported by GraphicsMagick");
        return this.out("-alpha", type);
      };
      proto.append = function append(img, ltr) {
        if (!this._append) {
          this._append = [];
          this.addSrcFormatter(function(src) {
            this.out(this._append.ltr ? "+append" : "-append");
            src.push.apply(src, this._append);
          });
        }
        if (0 === arguments.length) {
          this._append.ltr = false;
          return this;
        }
        for (var i = 0; i < arguments.length; ++i) {
          var arg = arguments[i];
          switch (isUtil(arg)) {
            case "Boolean":
              this._append.ltr = arg;
              break;
            case "String":
              this._append.push(arg);
              break;
            case "Array":
              for (var j = 0, len = arg.length; j < len; j++) {
                if (isUtil(arg[j]) == "String") {
                  this._append.push(arg[j]);
                }
              }
              break;
          }
        }
        return this;
      };
      proto.authenticate = function authenticate(string) {
        return this.out("-authenticate", string);
      };
      proto.average = function average() {
        return this.out("-average");
      };
      proto.backdrop = function backdrop() {
        return this.out("-backdrop");
      };
      proto.blackThreshold = function blackThreshold(red, green, blue, opacity) {
        return this.out("-black-threshold", argsToArray(red, green, blue, opacity).join(","));
      };
      proto.bluePrimary = function bluePrimary(x, y) {
        return this.out("-blue-primary", argsToArray(x, y).join(","));
      };
      proto.border = function border(width, height) {
        return this.out("-border", width + "x" + height);
      };
      proto.borderColor = function borderColor(color) {
        return this.out("-bordercolor", color);
      };
      proto.box = function box(color) {
        return this.out("-box", color);
      };
      proto.channel = function channel(type) {
        return this.out("-channel", type);
      };
      proto.chop = function chop(w, h, x, y) {
        return this.in("-chop", w + "x" + h + "+" + (x || 0) + "+" + (y || 0));
      };
      proto.clip = function clip() {
        return this.out("-clip");
      };
      proto.coalesce = function coalesce() {
        return this.out("-coalesce");
      };
      proto.colorize = function colorize(r, g, b) {
        return this.out("-colorize", [r, g, b].join(","));
      };
      proto.colorMap = function colorMap(type) {
        return this.out("-colormap", type);
      };
      proto.compose = function compose(operator) {
        return this.out("-compose", operator);
      };
      proto.compress = function compress(type) {
        return this.out("-compress", type);
      };
      proto.convolve = function convolve(kernel) {
        return this.out("-convolve", kernel);
      };
      proto.createDirectories = function createDirectories() {
        return this.out("-create-directories");
      };
      proto.deconstruct = function deconstruct() {
        return this.out("-deconstruct");
      };
      proto.define = function define(value) {
        return this.out("-define", value);
      };
      proto.delay = function delay(value) {
        return this.out("-delay", value);
      };
      proto.displace = function displace(horizontalScale, verticalScale) {
        return this.out("-displace", horizontalScale + "x" + verticalScale);
      };
      proto.display = function display(value) {
        return this.out("-display", value);
      };
      proto.dispose = function dispose(method) {
        return this.out("-dispose", method);
      };
      proto.dissolve = function dissolve(percent) {
        return this.out("-dissolve", percent + "%");
      };
      proto.encoding = function encoding(type) {
        return this.out("-encoding", type);
      };
      proto.endian = function endian(type) {
        return this.out("-endian", type);
      };
      proto.file = function file(filename) {
        return this.out("-file", filename);
      };
      proto.flatten = function flatten() {
        return this.out("-flatten");
      };
      proto.foreground = function foreground(color) {
        return this.out("-foreground", color);
      };
      proto.frame = function frame(width, height, outerBevelWidth, innerBevelWidth) {
        if (arguments.length == 0)
          return this.out("-frame");
        return this.out("-frame", width + "x" + height + "+" + outerBevelWidth + "+" + innerBevelWidth);
      };
      proto.fuzz = function fuzz(distance, percent) {
        return this.out("-fuzz", distance + (percent ? "%" : ""));
      };
      proto.gaussian = function gaussian(radius, sigma) {
        return this.out("-gaussian", argsToArray(radius, sigma).join("x"));
      };
      proto.geometry = function geometry(width, height, arg) {
        if (arguments.length == 1 && typeof arguments[0] === "string")
          return this.out("-geometry", arguments[0]);
        return this.out("-geometry", width + "x" + height + (arg || ""));
      };
      proto.greenPrimary = function greenPrimary(x, y) {
        return this.out("-green-primary", x + "," + y);
      };
      proto.highlightColor = function highlightColor(color) {
        return this.out("-highlight-color", color);
      };
      proto.highlightStyle = function highlightStyle(style) {
        return this.out("-highlight-style", style);
      };
      proto.iconGeometry = function iconGeometry(geometry) {
        return this.out("-iconGeometry", geometry);
      };
      proto.intent = function intent(type) {
        return this.out("-intent", type);
      };
      proto.lat = function lat(width, height, offset, percent) {
        return this.out("-lat", width + "x" + height + offset + (percent ? "%" : ""));
      };
      proto.level = function level(blackPoint, gamma, whitePoint, percent) {
        return this.out("-level", argsToArray(blackPoint, gamma, whitePoint).join(",") + (percent ? "%" : ""));
      };
      proto.list = function list(type) {
        return this.out("-list", type);
      };
      proto.log = function log(string) {
        return this.out("-log", string);
      };
      proto.loop = function loop(iterations) {
        return this.out("-loop", iterations);
      };
      proto.map = function map(filename) {
        return this.out("-map", filename);
      };
      proto.mask = function mask(filename) {
        return this.out("-mask", filename);
      };
      proto.matte = function matte() {
        return this.out("-matte");
      };
      proto.matteColor = function matteColor(color) {
        return this.out("-mattecolor", color);
      };
      proto.maximumError = function maximumError(limit) {
        return this.out("-maximum-error", limit);
      };
      proto.mode = function mode(value) {
        return this.out("-mode", value);
      };
      proto.monitor = function monitor() {
        return this.out("-monitor");
      };
      proto.mosaic = function mosaic() {
        return this.out("-mosaic");
      };
      proto.motionBlur = function motionBlur(radius, sigma, angle) {
        var arg = radius;
        if (typeof sigma != "undefined")
          arg += "x" + sigma;
        if (typeof angle != "undefined")
          arg += "+" + angle;
        return this.out("-motion-blur", arg);
      };
      proto.name = function name() {
        return this.out("-name");
      };
      proto.noop = function noop() {
        return this.out("-noop");
      };
      proto.normalize = function normalize() {
        return this.out("-normalize");
      };
      proto.opaque = function opaque(color) {
        return this.out("-opaque", color);
      };
      proto.operator = function operator(channel, operator, rvalue, percent) {
        return this.out("-operator", channel, operator, rvalue + (percent ? "%" : ""));
      };
      proto.orderedDither = function orderedDither(channeltype, NxN) {
        return this.out("-ordered-dither", channeltype, NxN);
      };
      proto.outputDirectory = function outputDirectory(directory) {
        return this.out("-output-directory", directory);
      };
      proto.page = function page(width, height, arg) {
        return this.out("-page", width + "x" + height + (arg || ""));
      };
      proto.pause = function pause(seconds) {
        return this.out("-pause", seconds);
      };
      proto.pen = function pen(color) {
        return this.out("-pen", color);
      };
      proto.ping = function ping() {
        return this.out("-ping");
      };
      proto.pointSize = function pointSize(value) {
        return this.out("-pointsize", value);
      };
      proto.preview = function preview(type) {
        return this.out("-preview", type);
      };
      proto.process = function process2(command) {
        return this.out("-process", command);
      };
      proto.profile = function profile(filename) {
        return this.out("-profile", filename);
      };
      proto.progress = function progress() {
        return this.out("+progress");
      };
      proto.randomThreshold = function randomThreshold(channeltype, LOWxHIGH) {
        return this.out("-random-threshold", channeltype, LOWxHIGH);
      };
      proto.recolor = function recolor(matrix) {
        return this.out("-recolor", matrix);
      };
      proto.redPrimary = function redPrimary(x, y) {
        return this.out("-red-primary", x, y);
      };
      proto.remote = function remote() {
        return this.out("-remote");
      };
      proto.render = function render() {
        return this.out("-render");
      };
      proto.repage = function repage(width, height, xoff, yoff, arg) {
        if (arguments[0] === "+")
          return this.out("+repage");
        return this.out("-repage", width + "x" + height + "+" + xoff + "+" + yoff + (arg || ""));
      };
      proto.sample = function sample(geometry) {
        return this.out("-sample", geometry);
      };
      proto.samplingFactor = function samplingFactor(horizontalFactor, verticalFactor) {
        return this.out("-sampling-factor", horizontalFactor + "x" + verticalFactor);
      };
      proto.scene = function scene(value) {
        return this.out("-scene", value);
      };
      proto.scenes = function scenes(start, end) {
        return this.out("-scenes", start + "-" + end);
      };
      proto.screen = function screen() {
        return this.out("-screen");
      };
      proto.set = function set(attribute, value) {
        return this.out("-set", attribute, value);
      };
      proto.segment = function segment(clusterThreshold, smoothingThreshold) {
        return this.out("-segment", clusterThreshold + "x" + smoothingThreshold);
      };
      proto.shade = function shade(azimuth, elevation) {
        return this.out("-shade", azimuth + "x" + elevation);
      };
      proto.shadow = function shadow(radius, sigma) {
        return this.out("-shadow", argsToArray(radius, sigma).join("x"));
      };
      proto.sharedMemory = function sharedMemory() {
        return this.out("-shared-memory");
      };
      proto.shave = function shave(width, height, percent) {
        return this.out("-shave", width + "x" + height + (percent ? "%" : ""));
      };
      proto.shear = function shear(xDegrees, yDegreees) {
        return this.out("-shear", xDegrees + "x" + yDegreees);
      };
      proto.silent = function silent(color) {
        return this.out("-silent");
      };
      proto.rawSize = function rawSize(width, height, offset) {
        var off = "undefined" != typeof offset ? "+" + offset : "";
        return this.out("-size", width + "x" + height + off);
      };
      proto.snaps = function snaps(value) {
        return this.out("-snaps", value);
      };
      proto.stegano = function stegano(offset) {
        return this.out("-stegano", offset);
      };
      proto.stereo = function stereo() {
        return this.out("-stereo");
      };
      proto.textFont = function textFont(name) {
        return this.out("-text-font", name);
      };
      proto.texture = function texture(filename) {
        return this.out("-texture", filename);
      };
      proto.threshold = function threshold(value, percent) {
        return this.out("-threshold", value + (percent ? "%" : ""));
      };
      proto.thumbnail = function thumbnail(w, h, options) {
        options = options || "";
        var geometry, wIsValid = Boolean(w || w === 0), hIsValid = Boolean(h || h === 0);
        if (wIsValid && hIsValid) {
          geometry = w + "x" + h + options;
        } else if (wIsValid) {
          geometry = this._options.imageMagick ? w + options : w + "x" + options;
        } else if (hIsValid) {
          geometry = "x" + h + options;
        } else {
          return this;
        }
        return this.out("-thumbnail", geometry);
      };
      proto.tile = function tile(filename) {
        return this.out("-tile", filename);
      };
      proto.title = function title(string) {
        return this.out("-title", string);
      };
      proto.transform = function transform(color) {
        return this.out("-transform", color);
      };
      proto.transparent = function transparent(color) {
        return this.out("-transparent", color);
      };
      proto.treeDepth = function treeDepth(value) {
        return this.out("-treedepth", value);
      };
      proto.update = function update(seconds) {
        return this.out("-update", seconds);
      };
      proto.units = function units(type) {
        return this.out("-units", type);
      };
      proto.unsharp = function unsharp(radius, sigma, amount, threshold) {
        var arg = radius;
        if (typeof sigma != "undefined")
          arg += "x" + sigma;
        if (typeof amount != "undefined")
          arg += "+" + amount;
        if (typeof threshold != "undefined")
          arg += "+" + threshold;
        return this.out("-unsharp", arg);
      };
      proto.usePixmap = function usePixmap() {
        return this.out("-use-pixmap");
      };
      proto.view = function view(string) {
        return this.out("-view", string);
      };
      proto.virtualPixel = function virtualPixel(method) {
        return this.out("-virtual-pixel", method);
      };
      proto.visual = function visual(type) {
        return this.out("-visual", type);
      };
      proto.watermark = function watermark(brightness, saturation) {
        return this.out("-watermark", brightness + "x" + saturation);
      };
      proto.wave = function wave(amplitude, wavelength) {
        return this.out("-wave", amplitude + "x" + wavelength);
      };
      proto.whitePoint = function whitePoint(x, y) {
        return this.out("-white-point", x + "x" + y);
      };
      proto.whiteThreshold = function whiteThreshold(red, green, blue, opacity) {
        return this.out("-white-threshold", argsToArray(red, green, blue, opacity).join(","));
      };
      proto.window = function window2(id) {
        return this.out("-window", id);
      };
      proto.windowGroup = function windowGroup() {
        return this.out("-window-group");
      };
      proto.strip = function strip() {
        if (this._options.imageMagick)
          return this.out("-strip");
        return this.noProfile().out("+comment");
      };
      proto.interlace = function interlace(type) {
        return this.out("-interlace", type || "None");
      };
      proto.setFormat = function setFormat(format) {
        if (format)
          this._outputFormat = format;
        return this;
      };
      proto.resize = function resize(w, h, options) {
        options = options || "";
        var geometry, wIsValid = Boolean(w || w === 0), hIsValid = Boolean(h || h === 0);
        if (wIsValid && hIsValid) {
          geometry = w + "x" + h + options;
        } else if (wIsValid) {
          geometry = this._options.imageMagick ? w + options : w + "x" + options;
        } else if (hIsValid) {
          geometry = "x" + h + options;
        } else {
          return this;
        }
        return this.out("-resize", geometry);
      };
      proto.resizeExact = function resize(w, h) {
        var options = "!";
        return proto.resize.apply(this, [w, h, options]);
      };
      proto.scale = function scale(w, h, options) {
        options = options || "";
        var geometry;
        if (w && h) {
          geometry = w + "x" + h + options;
        } else if (w && !h) {
          geometry = this._options.imageMagick ? w + options : w + "x" + options;
        } else if (!w && h) {
          geometry = "x" + h + options;
        }
        return this.out("-scale", geometry);
      };
      proto.filter = function filter(val) {
        return this.out("-filter", val);
      };
      proto.density = function density(w, h) {
        if (w && !h && this._options.imageMagick) {
          return this.in("-density", w);
        }
        return this.in("-density", w + "x" + h);
      };
      proto.noProfile = function noProfile() {
        this.out("+profile", '"*"');
        return this;
      };
      proto.resample = function resample(w, h) {
        return this.out("-resample", w + "x" + h);
      };
      proto.rotate = function rotate(color, deg) {
        return this.out("-background", color, "-rotate", String(deg || 0));
      };
      proto.flip = function flip() {
        return this.out("-flip");
      };
      proto.flop = function flop() {
        return this.out("-flop");
      };
      proto.crop = function crop(w, h, x, y, percent) {
        if (this.inputIs("jpg")) {
          var index = this._in.indexOf("-size");
          if (~index) {
            this._in.splice(index, 2);
          }
        }
        return this.out("-crop", w + "x" + h + "+" + (x || 0) + "+" + (y || 0) + (percent ? "%" : ""));
      };
      proto.magnify = function magnify(factor) {
        return this.in("-magnify");
      };
      proto.minify = function minify() {
        return this.in("-minify");
      };
      proto.quality = function quality(val) {
        return this.in("-quality", val || 75);
      };
      proto.blur = function blur(radius, sigma) {
        return this.out("-blur", radius + (sigma ? "x" + sigma : ""));
      };
      proto.charcoal = function charcoal(factor) {
        return this.out("-charcoal", factor || 2);
      };
      proto.modulate = function modulate(b, s, h) {
        return this.out("-modulate", [b, s, h].join(","));
      };
      proto.antialias = function antialias(disable) {
        return false === disable ? this.out("+antialias") : this;
      };
      proto.bitdepth = function bitdepth(val) {
        return this.out("-depth", val);
      };
      proto.colors = function colors(val) {
        return this.out("-colors", val || 128);
      };
      proto.colorspace = function colorspace(val) {
        return this.out("-colorspace", val);
      };
      proto.comment = comment("-comment");
      proto.contrast = function contrast(mult) {
        var arg = (parseInt(mult, 10) || 0) > 0 ? "+contrast" : "-contrast";
        mult = Math.abs(mult) || 1;
        while (mult--) {
          this.out(arg);
        }
        return this;
      };
      proto.cycle = function cycle(amount) {
        return this.out("-cycle", amount || 2);
      };
      proto.despeckle = function despeckle() {
        return this.out("-despeckle");
      };
      proto.dither = function dither(on) {
        var sign = false === on ? "+" : "-";
        return this.out(sign + "dither");
      };
      proto.monochrome = function monochrome() {
        return this.out("-monochrome");
      };
      proto.edge = function edge(radius) {
        return this.out("-edge", radius || 1);
      };
      proto.emboss = function emboss(radius) {
        return this.out("-emboss", radius || 1);
      };
      proto.enhance = function enhance() {
        return this.out("-enhance");
      };
      proto.equalize = function equalize() {
        return this.out("-equalize");
      };
      proto.gamma = function gamma(r, g, b) {
        return this.out("-gamma", [r, g, b].join());
      };
      proto.implode = function implode(factor) {
        return this.out("-implode", factor || 1);
      };
      proto.label = comment("-label");
      var limits = ["disk", "file", "map", "memory", "pixels", "threads"];
      proto.limit = function limit(type, val) {
        type = type.toLowerCase();
        if (!~limits.indexOf(type)) {
          return this;
        }
        return this.out("-limit", type, val);
      };
      proto.median = function median(radius) {
        return this.out("-median", radius || 1);
      };
      proto.negative = function negative(grayscale) {
        var sign = grayscale ? "+" : "-";
        return this.out(sign + "negate");
      };
      var noises = [
        "uniform",
        "gaussian",
        "multiplicative",
        "impulse",
        "laplacian",
        "poisson"
      ];
      proto.noise = function noise(radius) {
        radius = String(radius).toLowerCase();
        var sign = ~noises.indexOf(radius) ? "+" : "-";
        return this.out(sign + "noise", radius);
      };
      proto.paint = function paint(radius) {
        return this.out("-paint", radius);
      };
      proto.raise = function raise(w, h) {
        return this.out("-raise", (w || 0) + "x" + (h || 0));
      };
      proto.lower = function lower(w, h) {
        return this.out("+raise", (w || 0) + "x" + (h || 0));
      };
      proto.region = function region(w, h, x, y) {
        w = w || 0;
        h = h || 0;
        x = x || 0;
        y = y || 0;
        return this.out("-region", w + "x" + h + "+" + x + "+" + y);
      };
      proto.roll = function roll(x, y) {
        x = ((x = parseInt(x, 10) || 0) >= 0 ? "+" : "") + x;
        y = ((y = parseInt(y, 10) || 0) >= 0 ? "+" : "") + y;
        return this.out("-roll", x + y);
      };
      proto.sharpen = function sharpen(radius, sigma) {
        sigma = sigma ? "x" + sigma : "";
        return this.out("-sharpen", radius + sigma);
      };
      proto.solarize = function solarize(factor) {
        return this.out("-solarize", (factor || 1) + "%");
      };
      proto.spread = function spread(amount) {
        return this.out("-spread", amount || 5);
      };
      proto.swirl = function swirl(degrees) {
        return this.out("-swirl", degrees || 180);
      };
      proto.type = function type(type) {
        return this.in("-type", type);
      };
      proto.trim = function trim() {
        return this.out("-trim");
      };
      proto.extent = function extent(w, h, options) {
        options = options || "";
        var geometry;
        if (w && h) {
          geometry = w + "x" + h + options;
        } else if (w && !h) {
          geometry = this._options.imageMagick ? w + options : w + "x" + options;
        } else if (!w && h) {
          geometry = "x" + h + options;
        }
        return this.out("-extent", geometry);
      };
      proto.gravity = function gravity(type) {
        if (!type || !~gravity.types.indexOf(type)) {
          type = "NorthWest";
        }
        return this.out("-gravity", type);
      };
      proto.gravity.types = [
        "NorthWest",
        "North",
        "NorthEast",
        "West",
        "Center",
        "East",
        "SouthWest",
        "South",
        "SouthEast"
      ];
      proto.flatten = function flatten() {
        return this.out("-flatten");
      };
      proto.background = function background(color) {
        return this.in("-background", color);
      };
    };
    function comment(arg) {
      return function(format) {
        format = String(format);
        format = "@" == format.charAt(0) ? format.substring(1) : format;
        return this.out(arg, '"' + format + '"');
      };
    }
  }
});

// node_modules/gm/lib/drawing.js
var require_drawing = __commonJS({
  "node_modules/gm/lib/drawing.js"(exports, module2) {
    var escape = require_utils().escape;
    module2.exports = function(proto) {
      proto.fill = function fill(color) {
        return this.out("-fill", color || "none");
      };
      proto.stroke = function stroke(color, width) {
        if (width) {
          this.strokeWidth(width);
        }
        return this.out("-stroke", color || "none");
      };
      proto.strokeWidth = function strokeWidth(width) {
        return this.out("-strokewidth", width);
      };
      proto.font = function font(font, size) {
        if (size) {
          this.fontSize(size);
        }
        return this.out("-font", font);
      };
      proto.fontSize = function fontSize(size) {
        return this.out("-pointsize", size);
      };
      proto.draw = function draw(args) {
        return this.out("-draw", [].slice.call(arguments).join(" "));
      };
      proto.drawPoint = function drawPoint(x, y) {
        return this.draw("point", x + "," + y);
      };
      proto.drawLine = function drawLine(x0, y0, x1, y1) {
        return this.draw("line", x0 + "," + y0, x1 + "," + y1);
      };
      proto.drawRectangle = function drawRectangle(x0, y0, x1, y1, wc, hc) {
        var shape = "rectangle", lastarg;
        if ("undefined" !== typeof wc) {
          shape = "roundRectangle";
          if ("undefined" === typeof hc) {
            hc = wc;
          }
          lastarg = wc + "," + hc;
        }
        return this.draw(shape, x0 + "," + y0, x1 + "," + y1, lastarg);
      };
      proto.drawArc = function drawArc(x0, y0, x1, y1, a0, a1) {
        return this.draw("arc", x0 + "," + y0, x1 + "," + y1, a0 + "," + a1);
      };
      proto.drawEllipse = function drawEllipse(x0, y0, rx, ry, a0, a1) {
        if (a0 == void 0)
          a0 = 0;
        if (a1 == void 0)
          a1 = 360;
        return this.draw("ellipse", x0 + "," + y0, rx + "," + ry, a0 + "," + a1);
      };
      proto.drawCircle = function drawCircle(x0, y0, x1, y1) {
        return this.draw("circle", x0 + "," + y0, x1 + "," + y1);
      };
      proto.drawPolyline = function drawPolyline() {
        return this.draw("polyline", formatPoints(arguments));
      };
      proto.drawPolygon = function drawPolygon() {
        return this.draw("polygon", formatPoints(arguments));
      };
      proto.drawBezier = function drawBezier() {
        return this.draw("bezier", formatPoints(arguments));
      };
      proto._gravities = [
        "northwest",
        "north",
        "northeast",
        "west",
        "center",
        "east",
        "southwest",
        "south",
        "southeast"
      ];
      proto.drawText = function drawText(x0, y0, text, gravity) {
        var gravity = String(gravity || "").toLowerCase(), arg = ["text " + x0 + "," + y0 + " " + escape(text)];
        if (~this._gravities.indexOf(gravity)) {
          arg.unshift("gravity", gravity);
        }
        return this.draw.apply(this, arg);
      };
      proto._drawProps = ["color", "matte"];
      proto.setDraw = function setDraw(prop, x, y, method) {
        prop = String(prop || "").toLowerCase();
        if (!~this._drawProps.indexOf(prop)) {
          return this;
        }
        return this.draw(prop, x + "," + y, method);
      };
    };
    function formatPoints(points) {
      var len = points.length, result = [], i = 0;
      for (; i < len; ++i) {
        result.push(points[i].join(","));
      }
      return result;
    }
  }
});

// node_modules/gm/lib/convenience/thumb.js
var require_thumb = __commonJS({
  "node_modules/gm/lib/convenience/thumb.js"(exports, module2) {
    module2.exports = function(proto) {
      proto.thumb = function thumb(w, h, name, quality, align, progressive, callback, opts) {
        var self2 = this, args = Array.prototype.slice.call(arguments);
        opts = args.pop();
        if (typeof opts === "function") {
          callback = opts;
          opts = "";
        } else {
          callback = args.pop();
        }
        w = args.shift();
        h = args.shift();
        name = args.shift();
        quality = args.shift() || 63;
        align = args.shift() || "topleft";
        var interlace = args.shift() ? "Line" : "None";
        self2.size(function(err, size) {
          if (err) {
            return callback.apply(self2, arguments);
          }
          w = parseInt(w, 10);
          h = parseInt(h, 10);
          var w1, h1;
          var xoffset = 0;
          var yoffset = 0;
          if (size.width < size.height) {
            w1 = w;
            h1 = Math.floor(size.height * (w / size.width));
            if (h1 < h) {
              w1 = Math.floor(w1 * ((h - h1) / h + 1));
              h1 = h;
            }
          } else if (size.width > size.height) {
            h1 = h;
            w1 = Math.floor(size.width * (h / size.height));
            if (w1 < w) {
              h1 = Math.floor(h1 * ((w - w1) / w + 1));
              w1 = w;
            }
          } else if (size.width == size.height) {
            var bigger = w > h ? w : h;
            w1 = bigger;
            h1 = bigger;
          }
          if (align == "center") {
            if (w < w1) {
              xoffset = (w1 - w) / 2;
            }
            if (h < h1) {
              yoffset = (h1 - h) / 2;
            }
          }
          self2.quality(quality).in("-size", w1 + "x" + h1).scale(w1, h1, opts).crop(w, h, xoffset, yoffset).interlace(interlace).noProfile().write(name, function() {
            callback.apply(self2, arguments);
          });
        });
        return self2;
      };
      proto.thumbExact = function() {
        var self2 = this, args = Array.prototype.slice.call(arguments);
        args.push("!");
        self2.thumb.apply(self2, args);
      };
    };
  }
});

// node_modules/array-parallel/index.js
var require_array_parallel = __commonJS({
  "node_modules/array-parallel/index.js"(exports, module2) {
    module2.exports = function parallel(fns, context, callback) {
      if (!callback) {
        if (typeof context === "function") {
          callback = context;
          context = null;
        } else {
          callback = noop;
        }
      }
      var pending = fns && fns.length;
      if (!pending)
        return callback(null, []);
      var finished = false;
      var results = new Array(pending);
      fns.forEach(context ? function(fn, i) {
        fn.call(context, maybeDone(i));
      } : function(fn, i) {
        fn(maybeDone(i));
      });
      function maybeDone(i) {
        return function(err, result) {
          if (finished)
            return;
          if (err) {
            callback(err, results);
            finished = true;
            return;
          }
          results[i] = result;
          if (!--pending)
            callback(null, results);
        };
      }
    };
    function noop() {
    }
  }
});

// node_modules/gm/lib/convenience/morph.js
var require_morph = __commonJS({
  "node_modules/gm/lib/convenience/morph.js"(exports, module2) {
    var fs2 = require("fs");
    var parallel = require_array_parallel();
    module2.exports = function(proto) {
      function noop() {
      }
      proto.morph = function morph(other, outname, callback) {
        if (!outname) {
          throw new Error("an output filename is required");
        }
        callback = (callback || noop).bind(this);
        var self2 = this;
        if (Array.isArray(other)) {
          other.forEach(function(img) {
            self2.out(img);
          });
          self2.out("-morph", other.length);
        } else {
          self2.out(other, "-morph", 1);
        }
        self2.write(outname, function(err, stdout, stderr, cmd) {
          if (err)
            return callback(err, stdout, stderr, cmd);
          fs2.exists(outname, function(exists) {
            if (exists)
              return callback(null, stdout, stderr, cmd);
            parallel([
              fs2.unlink.bind(fs2, outname + ".0"),
              fs2.unlink.bind(fs2, outname + ".2"),
              fs2.rename.bind(fs2, outname + ".1", outname)
            ], function(err2) {
              callback(err2, stdout, stderr, cmd);
            });
          });
        });
        return self2;
      };
    };
  }
});

// node_modules/gm/lib/convenience/sepia.js
var require_sepia = __commonJS({
  "node_modules/gm/lib/convenience/sepia.js"(exports, module2) {
    module2.exports = function(proto) {
      proto.sepia = function sepia() {
        return this.modulate(115, 0, 100).colorize(7, 21, 50);
      };
    };
  }
});

// node_modules/gm/lib/convenience/autoOrient.js
var require_autoOrient = __commonJS({
  "node_modules/gm/lib/convenience/autoOrient.js"(exports, module2) {
    module2.exports = function(proto) {
      var exifTransforms = {
        topleft: "",
        topright: ["-flop"],
        bottomright: ["-rotate", 180],
        bottomleft: ["-flip"],
        lefttop: ["-flip", "-rotate", 90],
        righttop: ["-rotate", 90],
        rightbottom: ["-flop", "-rotate", 90],
        leftbottom: ["-rotate", 270]
      };
      proto.autoOrient = function autoOrient() {
        if (this._options.nativeAutoOrient || this._options.imageMagick) {
          this.out("-auto-orient");
          return this;
        }
        this.preprocessor(function(callback) {
          this.orientation({ bufferStream: true }, function(err, orientation) {
            if (err)
              return callback(err);
            var transforms = exifTransforms[orientation.toLowerCase()];
            if (transforms) {
              var index = this._out.indexOf(transforms[0]);
              if (~index) {
                this._out.splice(index, transforms.length);
              }
              this._out.unshift.apply(this._out, transforms.concat("-page", "+0+0"));
            }
            callback();
          });
        });
        return this;
      };
    };
  }
});

// node_modules/gm/lib/convenience.js
var require_convenience = __commonJS({
  "node_modules/gm/lib/convenience.js"(exports, module2) {
    module2.exports = function(proto) {
      require_thumb()(proto);
      require_morph()(proto);
      require_sepia()(proto);
      require_autoOrient()(proto);
    };
  }
});

// node_modules/pseudomap/pseudomap.js
var require_pseudomap = __commonJS({
  "node_modules/pseudomap/pseudomap.js"(exports, module2) {
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    module2.exports = PseudoMap;
    function PseudoMap(set2) {
      if (!(this instanceof PseudoMap))
        throw new TypeError("Constructor PseudoMap requires 'new'");
      this.clear();
      if (set2) {
        if (set2 instanceof PseudoMap || typeof Map === "function" && set2 instanceof Map)
          set2.forEach(function(value, key) {
            this.set(key, value);
          }, this);
        else if (Array.isArray(set2))
          set2.forEach(function(kv) {
            this.set(kv[0], kv[1]);
          }, this);
        else
          throw new TypeError("invalid argument");
      }
    }
    PseudoMap.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      Object.keys(this._data).forEach(function(k) {
        if (k !== "size")
          fn.call(thisp, this._data[k].value, this._data[k].key);
      }, this);
    };
    PseudoMap.prototype.has = function(k) {
      return !!find(this._data, k);
    };
    PseudoMap.prototype.get = function(k) {
      var res = find(this._data, k);
      return res && res.value;
    };
    PseudoMap.prototype.set = function(k, v) {
      set(this._data, k, v);
    };
    PseudoMap.prototype.delete = function(k) {
      var res = find(this._data, k);
      if (res) {
        delete this._data[res._index];
        this._data.size--;
      }
    };
    PseudoMap.prototype.clear = function() {
      var data = /* @__PURE__ */ Object.create(null);
      data.size = 0;
      Object.defineProperty(this, "_data", {
        value: data,
        enumerable: false,
        configurable: true,
        writable: false
      });
    };
    Object.defineProperty(PseudoMap.prototype, "size", {
      get: function() {
        return this._data.size;
      },
      set: function(n) {
      },
      enumerable: true,
      configurable: true
    });
    PseudoMap.prototype.values = PseudoMap.prototype.keys = PseudoMap.prototype.entries = function() {
      throw new Error("iterators are not implemented in this version");
    };
    function same(a, b) {
      return a === b || a !== a && b !== b;
    }
    function Entry(k, v, i) {
      this.key = k;
      this.value = v;
      this._index = i;
    }
    function find(data, k) {
      for (var i = 0, s = "_" + k, key = s; hasOwnProperty.call(data, key); key = s + i++) {
        if (same(data[key].key, k))
          return data[key];
      }
    }
    function set(data, k, v) {
      for (var i = 0, s = "_" + k, key = s; hasOwnProperty.call(data, key); key = s + i++) {
        if (same(data[key].key, k)) {
          data[key].value = v;
          return;
        }
      }
      data.size++;
      data[key] = new Entry(k, v, key);
    }
  }
});

// node_modules/pseudomap/map.js
var require_map = __commonJS({
  "node_modules/pseudomap/map.js"(exports, module2) {
    if (process.env.npm_package_name === "pseudomap" && process.env.npm_lifecycle_script === "test")
      process.env.TEST_PSEUDOMAP = "true";
    if (typeof Map === "function" && !process.env.TEST_PSEUDOMAP) {
      module2.exports = Map;
    } else {
      module2.exports = require_pseudomap();
    }
  }
});

// node_modules/gm/node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/gm/node_modules/yallist/yallist.js"(exports, module2) {
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
  }
});

// node_modules/gm/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/gm/node_modules/lru-cache/index.js"(exports, module2) {
    "use strict";
    module2.exports = LRUCache;
    var Map2 = require_map();
    var util2 = require("util");
    var Yallist = require_yallist();
    var hasSymbol = typeof Symbol === "function" && process.env._nodeLRUCacheForceNoSymbol !== "1";
    var makeSymbol;
    if (hasSymbol) {
      makeSymbol = function(key) {
        return Symbol(key);
      };
    } else {
      makeSymbol = function(key) {
        return "_" + key;
      };
    }
    var MAX = makeSymbol("max");
    var LENGTH = makeSymbol("length");
    var LENGTH_CALCULATOR = makeSymbol("lengthCalculator");
    var ALLOW_STALE = makeSymbol("allowStale");
    var MAX_AGE = makeSymbol("maxAge");
    var DISPOSE = makeSymbol("dispose");
    var NO_DISPOSE_ON_SET = makeSymbol("noDisposeOnSet");
    var LRU_LIST = makeSymbol("lruList");
    var CACHE = makeSymbol("cache");
    function naiveLength() {
      return 1;
    }
    function LRUCache(options) {
      if (!(this instanceof LRUCache)) {
        return new LRUCache(options);
      }
      if (typeof options === "number") {
        options = { max: options };
      }
      if (!options) {
        options = {};
      }
      var max = this[MAX] = options.max;
      if (!max || !(typeof max === "number") || max <= 0) {
        this[MAX] = Infinity;
      }
      var lc = options.length || naiveLength;
      if (typeof lc !== "function") {
        lc = naiveLength;
      }
      this[LENGTH_CALCULATOR] = lc;
      this[ALLOW_STALE] = options.stale || false;
      this[MAX_AGE] = options.maxAge || 0;
      this[DISPOSE] = options.dispose;
      this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
      this.reset();
    }
    Object.defineProperty(LRUCache.prototype, "max", {
      set: function(mL) {
        if (!mL || !(typeof mL === "number") || mL <= 0) {
          mL = Infinity;
        }
        this[MAX] = mL;
        trim(this);
      },
      get: function() {
        return this[MAX];
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "allowStale", {
      set: function(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      },
      get: function() {
        return this[ALLOW_STALE];
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "maxAge", {
      set: function(mA) {
        if (!mA || !(typeof mA === "number") || mA < 0) {
          mA = 0;
        }
        this[MAX_AGE] = mA;
        trim(this);
      },
      get: function() {
        return this[MAX_AGE];
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "lengthCalculator", {
      set: function(lC) {
        if (typeof lC !== "function") {
          lC = naiveLength;
        }
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach(function(hit) {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          }, this);
        }
        trim(this);
      },
      get: function() {
        return this[LENGTH_CALCULATOR];
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "length", {
      get: function() {
        return this[LENGTH];
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "itemCount", {
      get: function() {
        return this[LRU_LIST].length;
      },
      enumerable: true
    });
    LRUCache.prototype.rforEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this[LRU_LIST].tail; walker !== null; ) {
        var prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    };
    function forEachStep(self2, fn, node, thisp) {
      var hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE]) {
          hit = void 0;
        }
      }
      if (hit) {
        fn.call(thisp, hit.value, hit.key, self2);
      }
    }
    LRUCache.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this[LRU_LIST].head; walker !== null; ) {
        var next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    };
    LRUCache.prototype.keys = function() {
      return this[LRU_LIST].toArray().map(function(k) {
        return k.key;
      }, this);
    };
    LRUCache.prototype.values = function() {
      return this[LRU_LIST].toArray().map(function(k) {
        return k.value;
      }, this);
    };
    LRUCache.prototype.reset = function() {
      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach(function(hit) {
          this[DISPOSE](hit.key, hit.value);
        }, this);
      }
      this[CACHE] = new Map2();
      this[LRU_LIST] = new Yallist();
      this[LENGTH] = 0;
    };
    LRUCache.prototype.dump = function() {
      return this[LRU_LIST].map(function(hit) {
        if (!isStale(this, hit)) {
          return {
            k: hit.key,
            v: hit.value,
            e: hit.now + (hit.maxAge || 0)
          };
        }
      }, this).toArray().filter(function(h) {
        return h;
      });
    };
    LRUCache.prototype.dumpLru = function() {
      return this[LRU_LIST];
    };
    LRUCache.prototype.inspect = function(n, opts) {
      var str = "LRUCache {";
      var extras = false;
      var as = this[ALLOW_STALE];
      if (as) {
        str += "\n  allowStale: true";
        extras = true;
      }
      var max = this[MAX];
      if (max && max !== Infinity) {
        if (extras) {
          str += ",";
        }
        str += "\n  max: " + util2.inspect(max, opts);
        extras = true;
      }
      var maxAge = this[MAX_AGE];
      if (maxAge) {
        if (extras) {
          str += ",";
        }
        str += "\n  maxAge: " + util2.inspect(maxAge, opts);
        extras = true;
      }
      var lc = this[LENGTH_CALCULATOR];
      if (lc && lc !== naiveLength) {
        if (extras) {
          str += ",";
        }
        str += "\n  length: " + util2.inspect(this[LENGTH], opts);
        extras = true;
      }
      var didFirst = false;
      this[LRU_LIST].forEach(function(item) {
        if (didFirst) {
          str += ",\n  ";
        } else {
          if (extras) {
            str += ",\n";
          }
          didFirst = true;
          str += "\n  ";
        }
        var key = util2.inspect(item.key).split("\n").join("\n  ");
        var val = { value: item.value };
        if (item.maxAge !== maxAge) {
          val.maxAge = item.maxAge;
        }
        if (lc !== naiveLength) {
          val.length = item.length;
        }
        if (isStale(this, item)) {
          val.stale = true;
        }
        val = util2.inspect(val, opts).split("\n").join("\n  ");
        str += key + " => " + val;
      });
      if (didFirst || extras) {
        str += "\n";
      }
      str += "}";
      return str;
    };
    LRUCache.prototype.set = function(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      var now = maxAge ? Date.now() : 0;
      var len = this[LENGTH_CALCULATOR](value, key);
      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          del(this, this[CACHE].get(key));
          return false;
        }
        var node = this[CACHE].get(key);
        var item = node.value;
        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET]) {
            this[DISPOSE](key, item.value);
          }
        }
        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim(this);
        return true;
      }
      var hit = new Entry(key, value, len, now, maxAge);
      if (hit.length > this[MAX]) {
        if (this[DISPOSE]) {
          this[DISPOSE](key, value);
        }
        return false;
      }
      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim(this);
      return true;
    };
    LRUCache.prototype.has = function(key) {
      if (!this[CACHE].has(key))
        return false;
      var hit = this[CACHE].get(key).value;
      if (isStale(this, hit)) {
        return false;
      }
      return true;
    };
    LRUCache.prototype.get = function(key) {
      return get(this, key, true);
    };
    LRUCache.prototype.peek = function(key) {
      return get(this, key, false);
    };
    LRUCache.prototype.pop = function() {
      var node = this[LRU_LIST].tail;
      if (!node)
        return null;
      del(this, node);
      return node.value;
    };
    LRUCache.prototype.del = function(key) {
      del(this, this[CACHE].get(key));
    };
    LRUCache.prototype.load = function(arr) {
      this.reset();
      var now = Date.now();
      for (var l = arr.length - 1; l >= 0; l--) {
        var hit = arr[l];
        var expiresAt = hit.e || 0;
        if (expiresAt === 0) {
          this.set(hit.k, hit.v);
        } else {
          var maxAge = expiresAt - now;
          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    };
    LRUCache.prototype.prune = function() {
      var self2 = this;
      this[CACHE].forEach(function(value, key) {
        get(self2, key, false);
      });
    };
    function get(self2, key, doUse) {
      var node = self2[CACHE].get(key);
      if (node) {
        var hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            hit = void 0;
        } else {
          if (doUse) {
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        if (hit)
          hit = hit.value;
      }
      return hit;
    }
    function isStale(self2, hit) {
      if (!hit || !hit.maxAge && !self2[MAX_AGE]) {
        return false;
      }
      var stale = false;
      var diff = Date.now() - hit.now;
      if (hit.maxAge) {
        stale = diff > hit.maxAge;
      } else {
        stale = self2[MAX_AGE] && diff > self2[MAX_AGE];
      }
      return stale;
    }
    function trim(self2) {
      if (self2[LENGTH] > self2[MAX]) {
        for (var walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          var prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    }
    function del(self2, node) {
      if (node) {
        var hit = node.value;
        if (self2[DISPOSE]) {
          self2[DISPOSE](hit.key, hit.value);
        }
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    }
    function Entry(key, value, length, now, maxAge) {
      this.key = key;
      this.value = value;
      this.length = length;
      this.now = now;
      this.maxAge = maxAge || 0;
    }
  }
});

// node_modules/isexe/windows.js
var require_windows = __commonJS({
  "node_modules/isexe/windows.js"(exports, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs2 = require("fs");
    function checkPathExt(path3, options) {
      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i = 0; i < pathext.length; i++) {
        var p = pathext[i].toLowerCase();
        if (p && path3.substr(-p.length).toLowerCase() === p) {
          return true;
        }
      }
      return false;
    }
    function checkStat(stat, path3, options) {
      if (!stat.isSymbolicLink() && !stat.isFile()) {
        return false;
      }
      return checkPathExt(path3, options);
    }
    function isexe(path3, options, cb) {
      fs2.stat(path3, function(er, stat) {
        cb(er, er ? false : checkStat(stat, path3, options));
      });
    }
    function sync(path3, options) {
      return checkStat(fs2.statSync(path3), path3, options);
    }
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS({
  "node_modules/isexe/mode.js"(exports, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs2 = require("fs");
    function isexe(path3, options, cb) {
      fs2.stat(path3, function(er, stat) {
        cb(er, er ? false : checkStat(stat, options));
      });
    }
    function sync(path3, options) {
      return checkStat(fs2.statSync(path3), options);
    }
    function checkStat(stat, options) {
      return stat.isFile() && checkMode(stat, options);
    }
    function checkMode(stat, options) {
      var mod = stat.mode;
      var uid = stat.uid;
      var gid = stat.gid;
      var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
      var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
      var u = parseInt("100", 8);
      var g = parseInt("010", 8);
      var o = parseInt("001", 8);
      var ug = u | g;
      var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS({
  "node_modules/isexe/index.js"(exports, module2) {
    var fs2 = require("fs");
    var core;
    if (process.platform === "win32" || global.TESTING_WINDOWS) {
      core = require_windows();
    } else {
      core = require_mode();
    }
    module2.exports = isexe;
    isexe.sync = sync;
    function isexe(path3, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve2, reject) {
          isexe(path3, options || {}, function(er, is) {
            if (er) {
              reject(er);
            } else {
              resolve2(is);
            }
          });
        });
      }
      core(path3, options || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options && options.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb(er, is);
      });
    }
    function sync(path3, options) {
      try {
        return core.sync(path3, options || {});
      } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
  }
});

// node_modules/gm/node_modules/which/which.js
var require_which = __commonJS({
  "node_modules/gm/node_modules/which/which.js"(exports, module2) {
    module2.exports = which;
    which.sync = whichSync;
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path3 = require("path");
    var COLON = isWindows ? ";" : ":";
    var isexe = require_isexe();
    function getNotFoundError(cmd) {
      var er = new Error("not found: " + cmd);
      er.code = "ENOENT";
      return er;
    }
    function getPathInfo(cmd, opt) {
      var colon = opt.colon || COLON;
      var pathEnv = opt.path || process.env.PATH || "";
      var pathExt = [""];
      pathEnv = pathEnv.split(colon);
      var pathExtExe = "";
      if (isWindows) {
        pathEnv.unshift(process.cwd());
        pathExtExe = opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM";
        pathExt = pathExtExe.split(colon);
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      if (cmd.match(/\//) || isWindows && cmd.match(/\\/))
        pathEnv = [""];
      return {
        env: pathEnv,
        ext: pathExt,
        extExe: pathExtExe
      };
    }
    function which(cmd, opt, cb) {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      var info = getPathInfo(cmd, opt);
      var pathEnv = info.env;
      var pathExt = info.ext;
      var pathExtExe = info.extExe;
      var found = [];
      (function F(i, l) {
        if (i === l) {
          if (opt.all && found.length)
            return cb(null, found);
          else
            return cb(getNotFoundError(cmd));
        }
        var pathPart = pathEnv[i];
        if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
          pathPart = pathPart.slice(1, -1);
        var p = path3.join(pathPart, cmd);
        if (!pathPart && /^\.[\\\/]/.test(cmd)) {
          p = cmd.slice(0, 2) + p;
        }
        ;
        (function E(ii, ll) {
          if (ii === ll)
            return F(i + 1, l);
          var ext = pathExt[ii];
          isexe(p + ext, { pathExt: pathExtExe }, function(er, is) {
            if (!er && is) {
              if (opt.all)
                found.push(p + ext);
              else
                return cb(null, p + ext);
            }
            return E(ii + 1, ll);
          });
        })(0, pathExt.length);
      })(0, pathEnv.length);
    }
    function whichSync(cmd, opt) {
      opt = opt || {};
      var info = getPathInfo(cmd, opt);
      var pathEnv = info.env;
      var pathExt = info.ext;
      var pathExtExe = info.extExe;
      var found = [];
      for (var i = 0, l = pathEnv.length; i < l; i++) {
        var pathPart = pathEnv[i];
        if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
          pathPart = pathPart.slice(1, -1);
        var p = path3.join(pathPart, cmd);
        if (!pathPart && /^\.[\\\/]/.test(cmd)) {
          p = cmd.slice(0, 2) + p;
        }
        for (var j = 0, ll = pathExt.length; j < ll; j++) {
          var cur = p + pathExt[j];
          var is;
          try {
            is = isexe.sync(cur, { pathExt: pathExtExe });
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    }
  }
});

// node_modules/gm/node_modules/cross-spawn/lib/resolveCommand.js
var require_resolveCommand = __commonJS({
  "node_modules/gm/node_modules/cross-spawn/lib/resolveCommand.js"(exports, module2) {
    "use strict";
    var path3 = require("path");
    var which = require_which();
    var LRU = require_lru_cache();
    var commandCache = new LRU({ max: 50, maxAge: 30 * 1e3 });
    function resolveCommand(command, noExtension) {
      var resolved;
      noExtension = !!noExtension;
      resolved = commandCache.get(command + "!" + noExtension);
      if (commandCache.has(command)) {
        return commandCache.get(command);
      }
      try {
        resolved = !noExtension ? which.sync(command) : which.sync(command, { pathExt: path3.delimiter + (process.env.PATHEXT || "") });
      } catch (e) {
      }
      commandCache.set(command + "!" + noExtension, resolved);
      return resolved;
    }
    module2.exports = resolveCommand;
  }
});

// node_modules/gm/node_modules/cross-spawn/lib/hasBrokenSpawn.js
var require_hasBrokenSpawn = __commonJS({
  "node_modules/gm/node_modules/cross-spawn/lib/hasBrokenSpawn.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      if (process.platform !== "win32") {
        return false;
      }
      var nodeVer = process.version.substr(1).split(".").map(function(num) {
        return parseInt(num, 10);
      });
      return nodeVer[0] === 0 && nodeVer[1] < 12;
    }();
  }
});

// node_modules/gm/node_modules/cross-spawn/lib/parse.js
var require_parse = __commonJS({
  "node_modules/gm/node_modules/cross-spawn/lib/parse.js"(exports, module2) {
    "use strict";
    var fs2 = require("fs");
    var LRU = require_lru_cache();
    var resolveCommand = require_resolveCommand();
    var hasBrokenSpawn = require_hasBrokenSpawn();
    var isWin = process.platform === "win32";
    var shebangCache = new LRU({ max: 50, maxAge: 30 * 1e3 });
    function readShebang(command) {
      var buffer;
      var fd;
      var match;
      var shebang;
      if (shebangCache.has(command)) {
        return shebangCache.get(command);
      }
      buffer = new Buffer(150);
      try {
        fd = fs2.openSync(command, "r");
        fs2.readSync(fd, buffer, 0, 150, 0);
        fs2.closeSync(fd);
      } catch (e) {
      }
      match = buffer.toString().trim().match(/#!(.+)/i);
      if (match) {
        shebang = match[1].replace(/\/usr\/bin\/env\s+/i, "");
      }
      shebangCache.set(command, shebang);
      return shebang;
    }
    function escapeArg(arg, quote) {
      arg = "" + arg;
      if (!quote) {
        arg = arg.replace(/([\(\)%!\^<>&|;,"'\s])/g, "^$1");
      } else {
        arg = arg.replace(/(\\*)"/g, '$1$1\\"');
        arg = arg.replace(/(\\*)$/, "$1$1");
        arg = '"' + arg + '"';
      }
      return arg;
    }
    function escapeCommand(command) {
      return /^[a-z0-9_-]+$/i.test(command) ? command : escapeArg(command, true);
    }
    function requiresShell(command) {
      return !/\.(?:com|exe)$/i.test(command);
    }
    function parse2(command, args, options) {
      var shebang;
      var applyQuotes;
      var file;
      var original;
      var shell;
      if (args && !Array.isArray(args)) {
        options = args;
        args = null;
      }
      args = args ? args.slice(0) : [];
      options = options || {};
      original = command;
      if (isWin) {
        file = resolveCommand(command);
        file = file || resolveCommand(command, true);
        shebang = file && readShebang(file);
        shell = options.shell || hasBrokenSpawn;
        if (shebang) {
          args.unshift(file);
          command = shebang;
          shell = shell || requiresShell(resolveCommand(shebang) || resolveCommand(shebang, true));
        } else {
          shell = shell || requiresShell(file);
        }
        if (shell) {
          applyQuotes = command !== "echo";
          command = escapeCommand(command);
          args = args.map(function(arg) {
            return escapeArg(arg, applyQuotes);
          });
          args = ["/s", "/c", '"' + command + (args.length ? " " + args.join(" ") : "") + '"'];
          command = process.env.comspec || "cmd.exe";
          options.windowsVerbatimArguments = true;
        }
      }
      return {
        command,
        args,
        options,
        file,
        original
      };
    }
    module2.exports = parse2;
  }
});

// node_modules/gm/node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS({
  "node_modules/gm/node_modules/cross-spawn/lib/enoent.js"(exports, module2) {
    "use strict";
    var isWin = process.platform === "win32";
    var resolveCommand = require_resolveCommand();
    var isNode10 = process.version.indexOf("v0.10.") === 0;
    function notFoundError(command, syscall) {
      var err;
      err = new Error(syscall + " " + command + " ENOENT");
      err.code = err.errno = "ENOENT";
      err.syscall = syscall + " " + command;
      return err;
    }
    function hookChildProcess(cp, parsed) {
      var originalEmit;
      if (!isWin) {
        return;
      }
      originalEmit = cp.emit;
      cp.emit = function(name, arg1) {
        var err;
        if (name === "exit") {
          err = verifyENOENT(arg1, parsed, "spawn");
          if (err) {
            return originalEmit.call(cp, "error", err);
          }
        }
        return originalEmit.apply(cp, arguments);
      };
    }
    function verifyENOENT(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawn");
      }
      return null;
    }
    function verifyENOENTSync(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawnSync");
      }
      if (isNode10 && status === -1) {
        parsed.file = isWin ? parsed.file : resolveCommand(parsed.original);
        if (!parsed.file) {
          return notFoundError(parsed.original, "spawnSync");
        }
      }
      return null;
    }
    module2.exports.hookChildProcess = hookChildProcess;
    module2.exports.verifyENOENT = verifyENOENT;
    module2.exports.verifyENOENTSync = verifyENOENTSync;
    module2.exports.notFoundError = notFoundError;
  }
});

// node_modules/gm/node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS({
  "node_modules/gm/node_modules/cross-spawn/index.js"(exports, module2) {
    "use strict";
    var cp = require("child_process");
    var parse2 = require_parse();
    var enoent = require_enoent();
    var cpSpawnSync = cp.spawnSync;
    function spawn(command, args, options) {
      var parsed;
      var spawned;
      parsed = parse2(command, args, options);
      spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
      enoent.hookChildProcess(spawned, parsed);
      return spawned;
    }
    function spawnSync(command, args, options) {
      var parsed;
      var result;
      if (!cpSpawnSync) {
        try {
          cpSpawnSync = require("spawn-sync");
        } catch (ex) {
          throw new Error(
            "In order to use spawnSync on node 0.10 or older, you must install spawn-sync:\n\n  npm install spawn-sync --save"
          );
        }
      }
      parsed = parse2(command, args, options);
      result = cpSpawnSync(parsed.command, parsed.args, parsed.options);
      result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
      return result;
    }
    module2.exports = spawn;
    module2.exports.spawn = spawn;
    module2.exports.sync = spawnSync;
    module2.exports._parse = parse2;
    module2.exports._enoent = enoent;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/gm/node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/gm/node_modules/debug/src/common.js"(exports, module2) {
    "use strict";
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      Object.keys(env).forEach(function(key) {
        createDebug[key] = env[key];
      });
      createDebug.instances = [];
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        var hash = 0;
        for (var i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        var prevTime;
        function debug() {
          if (!debug.enabled) {
            return;
          }
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var self2 = debug;
          var curr = Number(new Date());
          var ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          var index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
            if (match === "%%") {
              return match;
            }
            index++;
            var formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              var val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          var logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.enabled = createDebug.enabled(namespace);
        debug.useColors = createDebug.useColors();
        debug.color = selectColor(namespace);
        debug.destroy = destroy;
        debug.extend = extend;
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        createDebug.instances.push(debug);
        return debug;
      }
      function destroy() {
        var index = createDebug.instances.indexOf(this);
        if (index !== -1) {
          createDebug.instances.splice(index, 1);
          return true;
        }
        return false;
      }
      function extend(namespace, delimiter) {
        return createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.names = [];
        createDebug.skips = [];
        var i;
        var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        var len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
        for (i = 0; i < createDebug.instances.length; i++) {
          var instance = createDebug.instances[i];
          instance.enabled = createDebug.enabled(instance.namespace);
        }
      }
      function disable() {
        createDebug.enable("");
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        var i;
        var len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/gm/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/gm/node_modules/debug/src/browser.js"(exports, module2) {
    "use strict";
    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      var _console;
      return (typeof console === "undefined" ? "undefined" : _typeof(console)) === "object" && console.log && (_console = console).log.apply(_console, arguments);
    }
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      var r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports);
    var formatters = module2.exports.formatters;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/array-series/index.js
var require_array_series = __commonJS({
  "node_modules/array-series/index.js"(exports, module2) {
    module2.exports = function series(fns, context, callback) {
      if (!callback) {
        if (typeof context === "function") {
          callback = context;
          context = null;
        } else {
          callback = noop;
        }
      }
      if (!(fns && fns.length))
        return callback();
      fns = fns.slice(0);
      var call = context ? function() {
        fns.length ? fns.shift().call(context, next) : callback();
      } : function() {
        fns.length ? fns.shift()(next) : callback();
      };
      call();
      function next(err) {
        err ? callback(err) : call();
      }
    };
    function noop() {
    }
  }
});

// node_modules/gm/lib/command.js
var require_command = __commonJS({
  "node_modules/gm/lib/command.js"(exports, module2) {
    var spawn = require_cross_spawn();
    var utils = require_utils();
    var debug = require_browser()("gm");
    var series = require_array_series();
    var PassThrough = require("stream").PassThrough;
    var noBufferConcat = "gm v1.9.0+ required node v0.8+. Please update your version of node, downgrade gm < 1.9, or do not use `bufferStream`.";
    module2.exports = function(proto) {
      function args(prop) {
        return function args2() {
          var len = arguments.length;
          var a = [];
          var i = 0;
          for (; i < len; ++i) {
            a.push(arguments[i]);
          }
          this[prop] = this[prop].concat(a);
          return this;
        };
      }
      function streamToUnemptyBuffer(stream2, callback) {
        var done = false;
        var buffers = [];
        stream2.on("data", function(data) {
          buffers.push(data);
        });
        stream2.on("end", function() {
          if (done)
            return;
          done = true;
          let result = Buffer.concat(buffers);
          buffers = null;
          if (result.length === 0) {
            const err = new Error("Stream yields empty buffer");
            callback(err, null);
          } else {
            callback(null, result);
          }
        });
        stream2.on("error", function(err) {
          done = true;
          buffers = null;
          callback(err);
        });
      }
      proto.in = args("_in");
      proto.out = args("_out");
      proto._preprocessor = [];
      proto.preprocessor = args("_preprocessor");
      proto.write = function write(name, callback) {
        if (!callback)
          callback = name, name = null;
        if ("function" !== typeof callback) {
          throw new TypeError("gm().write() expects a callback function");
        }
        if (!name) {
          return callback(TypeError("gm().write() expects a filename when writing new files"));
        }
        this.outname = name;
        var self2 = this;
        this._preprocess(function(err) {
          if (err)
            return callback(err);
          self2._spawn(self2.args(), true, callback);
        });
      };
      proto.stream = function stream2(format, callback) {
        if (!callback && typeof format === "function") {
          callback = format;
          format = null;
        }
        var throughStream;
        if ("function" !== typeof callback) {
          throughStream = new PassThrough();
          callback = function(err, stdout, stderr) {
            if (err)
              throughStream.emit("error", err);
            else
              stdout.pipe(throughStream);
          };
        }
        if (format) {
          format = format.split(".").pop();
          this.outname = format + ":-";
        }
        var self2 = this;
        this._preprocess(function(err) {
          if (err)
            return callback(err);
          return self2._spawn(self2.args(), false, callback);
        });
        return throughStream || this;
      };
      proto.toBuffer = function toBuffer(format, callback) {
        if (!callback)
          callback = format, format = null;
        if ("function" !== typeof callback) {
          throw new Error("gm().toBuffer() expects a callback.");
        }
        return this.stream(format, function(err, stdout) {
          if (err)
            return callback(err);
          streamToUnemptyBuffer(stdout, callback);
        });
      };
      proto._preprocess = function _preprocess(callback) {
        series(this._preprocessor, this, callback);
      };
      proto._exec = function _exec(args2, callback) {
        return this._spawn(args2, true, callback);
      };
      proto._spawn = function _spawn(args2, bufferOutput, callback) {
        var appPath = this._options.appPath || "";
        var bin;
        switch (this._options.imageMagick) {
          case true:
            bin = args2.shift();
            break;
          case "7+":
            bin = "magick";
            break;
          default:
            bin = "gm";
            break;
        }
        bin = appPath + bin;
        var cmd = bin + " " + args2.map(utils.escape).join(" "), self2 = this, proc, err, timeout = parseInt(this._options.timeout), disposers = this._options.disposers, timeoutId;
        debug(cmd);
        if (args2.indexOf("-minify") > -1 && this._options.imageMagick) {
          return cb(new Error("imageMagick does not support minify, use -scale or -sample. Alternatively, use graphicsMagick"));
        }
        try {
          proc = spawn(bin, args2);
        } catch (e) {
          return cb(e);
        }
        proc.stdin.once("error", cb);
        proc.on("error", function(err2) {
          if (err2.code === "ENOENT") {
            cb(new Error("Could not execute GraphicsMagick/ImageMagick: " + cmd + " this most likely means the gm/convert binaries can't be found"));
          } else {
            cb(err2);
          }
        });
        if (timeout) {
          timeoutId = setTimeout(function() {
            dispose("gm() resulted in a timeout.");
          }, timeout);
        }
        if (disposers) {
          disposers.forEach(function(disposer) {
            disposer.events.forEach(function(event) {
              disposer.emitter.on(event, dispose);
            });
          });
        }
        if (self2.sourceBuffer) {
          proc.stdin.write(this.sourceBuffer);
          proc.stdin.end();
        } else if (self2.sourceStream) {
          if (!self2.sourceStream.readable) {
            return cb(new Error("gm().stream() or gm().write() with a non-readable stream."));
          }
          self2.sourceStream.pipe(proc.stdin);
          if (self2.bufferStream && !this._buffering) {
            if (!Buffer.concat) {
              throw new Error(noBufferConcat);
            }
            self2._buffering = true;
            streamToUnemptyBuffer(self2.sourceStream, function(err2, buffer) {
              self2.sourceBuffer = buffer;
              self2.sourceStream = null;
            });
          }
        }
        if (bufferOutput) {
          var stdout = "", stderr = "", onOut, onErr, onExit;
          proc.stdout.on("data", onOut = function(data) {
            stdout += data;
          });
          proc.stderr.on("data", onErr = function(data) {
            stderr += data;
          });
          proc.on("close", onExit = function(code, signal) {
            let err2;
            if (code !== 0 || signal !== null) {
              err2 = new Error("Command failed: " + stderr);
              err2.code = code;
              err2.signal = signal;
            }
            ;
            cb(err2, stdout, stderr, cmd);
            stdout = stderr = onOut = onErr = onExit = null;
          });
        } else {
          cb(null, proc.stdout, proc.stderr, cmd);
        }
        return self2;
        function cb(err2, stdout2, stderr2, cmd2) {
          if (cb.called)
            return;
          if (timeoutId)
            clearTimeout(timeoutId);
          cb.called = 1;
          if (args2[0] !== "identify" && bin !== "identify") {
            self2._in = [];
            self2._out = [];
          }
          callback.call(self2, err2, stdout2, stderr2, cmd2);
        }
        function dispose(msg) {
          const message = msg ? msg : "gm() was disposed";
          const err2 = new Error(message);
          cb(err2);
          if (proc.exitCode === null) {
            proc.stdin.pause();
            proc.kill();
          }
        }
      };
      proto.args = function args2() {
        var outname = this.outname || "-";
        if (this._outputFormat)
          outname = this._outputFormat + ":" + outname;
        return [].concat(
          this._subCommand,
          this._in,
          this.src(),
          this._out,
          outname
        ).filter(Boolean);
      };
      proto.addSrcFormatter = function addSrcFormatter(formatter) {
        if ("function" != typeof formatter)
          throw new TypeError("sourceFormatter must be a function");
        this._sourceFormatters || (this._sourceFormatters = []);
        this._sourceFormatters.push(formatter);
        return this;
      };
      proto.src = function src() {
        var arr = [];
        for (var i = 0; i < this._sourceFormatters.length; ++i) {
          this._sourceFormatters[i].call(this, arr);
        }
        return arr;
      };
      var types = {
        "jpg": /\.jpe?g$/i,
        "png": /\.png$/i,
        "gif": /\.gif$/i,
        "tiff": /\.tif?f$/i,
        "bmp": /(?:\.bmp|\.dib)$/i,
        "webp": /\.webp$/i
      };
      types.jpeg = types.jpg;
      types.tif = types.tiff;
      types.dib = types.bmp;
      proto.inputIs = function inputIs(type) {
        if (!type)
          return false;
        var rgx = types[type];
        if (!rgx) {
          if ("." !== type[0])
            type = "." + type;
          rgx = new RegExp("\\" + type + "$", "i");
        }
        return rgx.test(this.source);
      };
      proto.addDisposer = function addDisposer(emitter, events) {
        if (!this._options.disposers) {
          this._options.disposers = [];
        }
        this._options.disposers.push({
          emitter,
          events
        });
        return this;
      };
    };
  }
});

// node_modules/gm/lib/compare.js
var require_compare = __commonJS({
  "node_modules/gm/lib/compare.js"(exports, module2) {
    var spawn = require_cross_spawn();
    var debug = require_browser()("gm");
    var utils = require_utils();
    module2.exports = exports = function(proto) {
      function compare(orig, compareTo, options, cb) {
        var isImageMagick = this._options && this._options.imageMagick;
        var appPath = this._options && this._options.appPath || "";
        var args = ["-metric", "mse", orig, compareTo];
        let bin;
        switch (isImageMagick) {
          case true:
            bin = "compare";
            break;
          case "7+":
            bin = "magick";
            args.unshift("compare");
            break;
          default:
            bin = "gm";
            args.unshift("compare");
            break;
        }
        bin = appPath + bin;
        var tolerance = 0.4;
        if (typeof options === "object") {
          if (options.highlightColor && options.highlightColor.indexOf('"') < 0) {
            options.highlightColor = '"' + options.highlightColor + '"';
          }
          if (options.file) {
            if (typeof options.file !== "string") {
              throw new TypeError("The path for the diff output is invalid");
            }
            if (options.highlightColor) {
              args.push("-highlight-color");
              args.push(options.highlightColor);
            }
            if (options.highlightStyle) {
              args.push("-highlight-style");
              args.push(options.highlightStyle);
            }
            if (!isImageMagick) {
              args.push("-file");
            }
            args.push(options.file);
          }
          if (typeof options.tolerance != "undefined") {
            if (typeof options.tolerance !== "number") {
              throw new TypeError("The tolerance value should be a number");
            }
            tolerance = options.tolerance;
          }
        } else {
          if (isImageMagick) {
            args.push("null:");
          }
          if (typeof options == "function") {
            cb = options;
          } else {
            tolerance = options;
          }
        }
        var cmd = bin + " " + args.map(utils.escape).join(" ");
        debug(cmd);
        var proc = spawn(bin, args);
        var stdout = "";
        var stderr = "";
        proc.stdout.on("data", function(data) {
          stdout += data;
        });
        proc.stderr.on("data", function(data) {
          stderr += data;
        });
        proc.on("close", function(code) {
          if (isImageMagick) {
            if (code === 0) {
              return cb(null, 0 <= tolerance, 0, stdout);
            } else if (code === 1) {
              stdout = stderr;
            } else {
              return cb(stderr);
            }
          } else {
            if (code !== 0) {
              return cb(stderr);
            }
          }
          var regex = isImageMagick ? /\((\d+\.?[\d\-\+e]*)\)/m : /Total: (\d+\.?\d*)/m;
          var match = regex.exec(stdout);
          if (!match) {
            return cb(new Error("Unable to parse output.\nGot " + stdout));
          }
          var equality = parseFloat(match[1]);
          cb(null, equality <= tolerance, equality, stdout, orig, compareTo);
        });
      }
      if (proto) {
        proto.compare = compare;
      }
      return compare;
    };
  }
});

// node_modules/gm/lib/composite.js
var require_composite = __commonJS({
  "node_modules/gm/lib/composite.js"(exports, module2) {
    module2.exports = exports = function(proto) {
      proto.composite = function(other, mask) {
        this.in(other);
        if (typeof mask !== "undefined")
          this.out(mask);
        this.subCommand("composite");
        return this;
      };
    };
  }
});

// node_modules/gm/lib/montage.js
var require_montage = __commonJS({
  "node_modules/gm/lib/montage.js"(exports, module2) {
    module2.exports = exports = function(proto) {
      proto.montage = function(other) {
        this.in(other);
        this.subCommand("montage");
        return this;
      };
    };
  }
});

// node_modules/gm/package.json
var require_package = __commonJS({
  "node_modules/gm/package.json"(exports, module2) {
    module2.exports = {
      name: "gm",
      description: "GraphicsMagick and ImageMagick for node.js",
      version: "1.25.0",
      author: "Aaron Heckmann <aaron.heckmann+github@gmail.com>",
      keywords: [
        "graphics",
        "magick",
        "image",
        "graphicsmagick",
        "imagemagick",
        "gm",
        "convert",
        "identify",
        "compare"
      ],
      engines: {
        node: ">=14"
      },
      bugs: {
        url: "http://github.com/aheckmann/gm/issues"
      },
      licenses: [
        {
          type: "MIT",
          url: "http://www.opensource.org/licenses/mit-license.php"
        }
      ],
      main: "./index",
      scripts: {
        security: "npm audit",
        test: "npm run security && npm run test-integration",
        "test-integration": "node test/ --integration",
        "test-unit": "node test/"
      },
      repository: {
        type: "git",
        url: "https://github.com/aheckmann/gm.git"
      },
      license: "MIT",
      devDependencies: {
        async: "~0.9.0"
      },
      dependencies: {
        "array-parallel": "~0.1.3",
        "array-series": "~0.1.5",
        "cross-spawn": "^4.0.0",
        debug: "^3.1.0"
      }
    };
  }
});

// node_modules/gm/index.js
var require_gm = __commonJS({
  "node_modules/gm/index.js"(exports, module2) {
    var Stream = require("stream").Stream;
    var EventEmitter = require("events").EventEmitter;
    var util2 = require("util");
    util2.inherits(gm2, EventEmitter);
    function gm2(source, height, color) {
      var width;
      if (!(this instanceof gm2)) {
        return new gm2(source, height, color);
      }
      EventEmitter.call(this);
      this._options = {};
      this.options(this.__proto__._options);
      this.data = {};
      this._in = [];
      this._out = [];
      this._outputFormat = null;
      this._subCommand = "convert";
      if (source instanceof Stream) {
        this.sourceStream = source;
        source = height || "unknown.jpg";
      } else if (Buffer.isBuffer(source)) {
        this.sourceBuffer = source;
        source = height || "unknown.jpg";
      } else if (height) {
        width = source;
        source = "";
        this.in("-size", width + "x" + height);
        if (color) {
          this.in("xc:" + color);
        }
      }
      if (typeof source === "string") {
        var frames = source.match(/(\[.+\])$/);
        if (frames) {
          this.sourceFrames = source.substr(frames.index, frames[0].length);
          source = source.substr(0, frames.index);
        }
      }
      this.source = source;
      this.addSrcFormatter(function(src) {
        var inputFromStdin = this.sourceStream || this.sourceBuffer;
        var ret = inputFromStdin ? "-" : this.source;
        const fileNameProvied = typeof height === "string";
        if (inputFromStdin && fileNameProvied && /\.ico$/i.test(this.source)) {
          ret = `ico:-`;
        }
        if (ret && this.sourceFrames)
          ret += this.sourceFrames;
        src.length = 0;
        src[0] = ret;
      });
    }
    var parent = gm2;
    gm2.subClass = function subClass(options) {
      function gm3(source, height, color) {
        if (!(this instanceof parent)) {
          return new gm3(source, height, color);
        }
        parent.call(this, source, height, color);
      }
      gm3.prototype.__proto__ = parent.prototype;
      gm3.prototype._options = {};
      gm3.prototype.options(options);
      return gm3;
    };
    require_options()(gm2.prototype);
    require_getters()(gm2);
    require_args()(gm2.prototype);
    require_drawing()(gm2.prototype);
    require_convenience()(gm2.prototype);
    require_command()(gm2.prototype);
    require_compare()(gm2.prototype);
    require_composite()(gm2.prototype);
    require_montage()(gm2.prototype);
    module2.exports = exports = gm2;
    module2.exports.utils = require_utils();
    module2.exports.compare = require_compare()();
    module2.exports.version = require_package().version;
  }
});

// node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS({
  "node_modules/quick-format-unescaped/index.js"(exports, module2) {
    "use strict";
    function tryStringify(o) {
      try {
        return JSON.stringify(o);
      } catch (e) {
        return '"[Circular]"';
      }
    }
    module2.exports = format;
    function format(f, args, opts) {
      var ss = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f === "object" && f !== null) {
        var len = args.length + offset;
        if (len === 1)
          return f;
        var objects = new Array(len);
        objects[0] = ss(f);
        for (var index = 1; index < len; index++) {
          objects[index] = ss(args[index]);
        }
        return objects.join(" ");
      }
      if (typeof f !== "string") {
        return f;
      }
      var argLen = args.length;
      if (argLen === 0)
        return f;
      var str = "";
      var a = 1 - offset;
      var lastPos = -1;
      var flen = f && f.length || 0;
      for (var i = 0; i < flen; ) {
        if (f.charCodeAt(i) === 37 && i + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f.charCodeAt(i + 1)) {
            case 100:
            case 102:
              if (a >= argLen)
                break;
              if (args[a] == null)
                break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += Number(args[a]);
              lastPos = i + 2;
              i++;
              break;
            case 105:
              if (a >= argLen)
                break;
              if (args[a] == null)
                break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += Math.floor(Number(args[a]));
              lastPos = i + 2;
              i++;
              break;
            case 79:
            case 111:
            case 106:
              if (a >= argLen)
                break;
              if (args[a] === void 0)
                break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              var type = typeof args[a];
              if (type === "string") {
                str += "'" + args[a] + "'";
                lastPos = i + 2;
                i++;
                break;
              }
              if (type === "function") {
                str += args[a].name || "<anonymous>";
                lastPos = i + 2;
                i++;
                break;
              }
              str += ss(args[a]);
              lastPos = i + 2;
              i++;
              break;
            case 115:
              if (a >= argLen)
                break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += String(args[a]);
              lastPos = i + 2;
              i++;
              break;
            case 37:
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += "%";
              lastPos = i + 2;
              i++;
              a--;
              break;
          }
          ++a;
        }
        ++i;
      }
      if (lastPos === -1)
        return f;
      else if (lastPos < flen) {
        str += f.slice(lastPos);
      }
      return str;
    }
  }
});

// node_modules/pino/browser.js
var require_browser2 = __commonJS({
  "node_modules/pino/browser.js"(exports, module2) {
    "use strict";
    var format = require_quick_format_unescaped();
    module2.exports = pino2;
    var _console = pfGlobalThisOrFallback().console || {};
    var stdSerializers = {
      mapHttpRequest: mock,
      mapHttpResponse: mock,
      wrapRequestSerializer: passthrough,
      wrapResponseSerializer: passthrough,
      wrapErrorSerializer: passthrough,
      req: mock,
      res: mock,
      err: asErrValue,
      errWithCause: asErrValue
    };
    function shouldSerialize(serialize, serializers) {
      if (Array.isArray(serialize)) {
        const hasToFilter = serialize.filter(function(k) {
          return k !== "!stdSerializers.err";
        });
        return hasToFilter;
      } else if (serialize === true) {
        return Object.keys(serializers);
      }
      return false;
    }
    function pino2(opts) {
      opts = opts || {};
      opts.browser = opts.browser || {};
      const transmit2 = opts.browser.transmit;
      if (transmit2 && typeof transmit2.send !== "function") {
        throw Error("pino: transmit option must have a send function");
      }
      const proto = opts.browser.write || _console;
      if (opts.browser.write)
        opts.browser.asObject = true;
      const serializers = opts.serializers || {};
      const serialize = shouldSerialize(opts.browser.serialize, serializers);
      let stdErrSerialize = opts.browser.serialize;
      if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf("!stdSerializers.err") > -1)
        stdErrSerialize = false;
      const customLevels = Object.keys(opts.customLevels || {});
      const levels = ["error", "fatal", "warn", "info", "debug", "trace"].concat(customLevels);
      if (typeof proto === "function") {
        levels.forEach(function(level2) {
          proto[level2] = proto;
        });
      }
      if (opts.enabled === false || opts.browser.disabled)
        opts.level = "silent";
      const level = opts.level || "info";
      const logger2 = Object.create(proto);
      if (!logger2.log)
        logger2.log = noop;
      Object.defineProperty(logger2, "levelVal", {
        get: getLevelVal
      });
      Object.defineProperty(logger2, "level", {
        get: getLevel,
        set: setLevel
      });
      const setOpts = {
        transmit: transmit2,
        serialize,
        asObject: opts.browser.asObject,
        levels,
        timestamp: getTimeFunction(opts)
      };
      logger2.levels = getLevels(opts);
      logger2.level = level;
      logger2.setMaxListeners = logger2.getMaxListeners = logger2.emit = logger2.addListener = logger2.on = logger2.prependListener = logger2.once = logger2.prependOnceListener = logger2.removeListener = logger2.removeAllListeners = logger2.listeners = logger2.listenerCount = logger2.eventNames = logger2.write = logger2.flush = noop;
      logger2.serializers = serializers;
      logger2._serialize = serialize;
      logger2._stdErrSerialize = stdErrSerialize;
      logger2.child = child;
      if (transmit2)
        logger2._logEvent = createLogEventShape();
      function getLevelVal() {
        return this.level === "silent" ? Infinity : this.levels.values[this.level];
      }
      function getLevel() {
        return this._level;
      }
      function setLevel(level2) {
        if (level2 !== "silent" && !this.levels.values[level2]) {
          throw Error("unknown level " + level2);
        }
        this._level = level2;
        set(setOpts, logger2, "error", "log");
        set(setOpts, logger2, "fatal", "error");
        set(setOpts, logger2, "warn", "error");
        set(setOpts, logger2, "info", "log");
        set(setOpts, logger2, "debug", "log");
        set(setOpts, logger2, "trace", "log");
        customLevels.forEach(function(level3) {
          set(setOpts, logger2, level3, "log");
        });
      }
      function child(bindings, childOptions) {
        if (!bindings) {
          throw new Error("missing bindings for child Pino");
        }
        childOptions = childOptions || {};
        if (serialize && bindings.serializers) {
          childOptions.serializers = bindings.serializers;
        }
        const childOptionsSerializers = childOptions.serializers;
        if (serialize && childOptionsSerializers) {
          var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
          var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize;
          delete bindings.serializers;
          applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
        }
        function Child(parent) {
          this._childLevel = (parent._childLevel | 0) + 1;
          this.error = bind(parent, bindings, "error");
          this.fatal = bind(parent, bindings, "fatal");
          this.warn = bind(parent, bindings, "warn");
          this.info = bind(parent, bindings, "info");
          this.debug = bind(parent, bindings, "debug");
          this.trace = bind(parent, bindings, "trace");
          if (childSerializers) {
            this.serializers = childSerializers;
            this._serialize = childSerialize;
          }
          if (transmit2) {
            this._logEvent = createLogEventShape(
              [].concat(parent._logEvent.bindings, bindings)
            );
          }
        }
        Child.prototype = this;
        return new Child(this);
      }
      return logger2;
    }
    function getLevels(opts) {
      const customLevels = opts.customLevels || {};
      const values = Object.assign({}, pino2.levels.values, customLevels);
      const labels = Object.assign({}, pino2.levels.labels, invertObject(customLevels));
      return {
        values,
        labels
      };
    }
    function invertObject(obj) {
      const inverted = {};
      Object.keys(obj).forEach(function(key) {
        inverted[obj[key]] = key;
      });
      return inverted;
    }
    pino2.levels = {
      values: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
      },
      labels: {
        10: "trace",
        20: "debug",
        30: "info",
        40: "warn",
        50: "error",
        60: "fatal"
      }
    };
    pino2.stdSerializers = stdSerializers;
    pino2.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
    function set(opts, logger2, level, fallback) {
      const proto = Object.getPrototypeOf(logger2);
      logger2[level] = logger2.levelVal > logger2.levels.values[level] ? noop : proto[level] ? proto[level] : _console[level] || _console[fallback] || noop;
      wrap(opts, logger2, level);
    }
    function wrap(opts, logger2, level) {
      if (!opts.transmit && logger2[level] === noop)
        return;
      logger2[level] = function(write) {
        return function LOG() {
          const ts = opts.timestamp();
          const args = new Array(arguments.length);
          const proto = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
          for (var i = 0; i < args.length; i++)
            args[i] = arguments[i];
          if (opts.serialize && !opts.asObject) {
            applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
          }
          if (opts.asObject)
            write.call(proto, asObject(this, level, args, ts));
          else
            write.apply(proto, args);
          if (opts.transmit) {
            const transmitLevel = opts.transmit.level || logger2.level;
            const transmitValue = logger2.levels.values[transmitLevel];
            const methodValue = logger2.levels.values[level];
            if (methodValue < transmitValue)
              return;
            transmit(this, {
              ts,
              methodLevel: level,
              methodValue,
              transmitLevel,
              transmitValue: logger2.levels.values[opts.transmit.level || logger2.level],
              send: opts.transmit.send,
              val: logger2.levelVal
            }, args);
          }
        };
      }(logger2[level]);
    }
    function asObject(logger2, level, args, ts) {
      if (logger2._serialize)
        applySerializers(args, logger2._serialize, logger2.serializers, logger2._stdErrSerialize);
      const argsCloned = args.slice();
      let msg = argsCloned[0];
      const o = {};
      if (ts) {
        o.time = ts;
      }
      o.level = logger2.levels.values[level];
      let lvl = (logger2._childLevel | 0) + 1;
      if (lvl < 1)
        lvl = 1;
      if (msg !== null && typeof msg === "object") {
        while (lvl-- && typeof argsCloned[0] === "object") {
          Object.assign(o, argsCloned.shift());
        }
        msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : void 0;
      } else if (typeof msg === "string")
        msg = format(argsCloned.shift(), argsCloned);
      if (msg !== void 0)
        o.msg = msg;
      return o;
    }
    function applySerializers(args, serialize, serializers, stdErrSerialize) {
      for (const i in args) {
        if (stdErrSerialize && args[i] instanceof Error) {
          args[i] = pino2.stdSerializers.err(args[i]);
        } else if (typeof args[i] === "object" && !Array.isArray(args[i])) {
          for (const k in args[i]) {
            if (serialize && serialize.indexOf(k) > -1 && k in serializers) {
              args[i][k] = serializers[k](args[i][k]);
            }
          }
        }
      }
    }
    function bind(parent, bindings, level) {
      return function() {
        const args = new Array(1 + arguments.length);
        args[0] = bindings;
        for (var i = 1; i < args.length; i++) {
          args[i] = arguments[i - 1];
        }
        return parent[level].apply(this, args);
      };
    }
    function transmit(logger2, opts, args) {
      const send = opts.send;
      const ts = opts.ts;
      const methodLevel = opts.methodLevel;
      const methodValue = opts.methodValue;
      const val = opts.val;
      const bindings = logger2._logEvent.bindings;
      applySerializers(
        args,
        logger2._serialize || Object.keys(logger2.serializers),
        logger2.serializers,
        logger2._stdErrSerialize === void 0 ? true : logger2._stdErrSerialize
      );
      logger2._logEvent.ts = ts;
      logger2._logEvent.messages = args.filter(function(arg) {
        return bindings.indexOf(arg) === -1;
      });
      logger2._logEvent.level.label = methodLevel;
      logger2._logEvent.level.value = methodValue;
      send(methodLevel, logger2._logEvent, val);
      logger2._logEvent = createLogEventShape(bindings);
    }
    function createLogEventShape(bindings) {
      return {
        ts: 0,
        messages: [],
        bindings: bindings || [],
        level: { label: "", value: 0 }
      };
    }
    function asErrValue(err) {
      const obj = {
        type: err.constructor.name,
        msg: err.message,
        stack: err.stack
      };
      for (const key in err) {
        if (obj[key] === void 0) {
          obj[key] = err[key];
        }
      }
      return obj;
    }
    function getTimeFunction(opts) {
      if (typeof opts.timestamp === "function") {
        return opts.timestamp;
      }
      if (opts.timestamp === false) {
        return nullTime;
      }
      return epochTime;
    }
    function mock() {
      return {};
    }
    function passthrough(a) {
      return a;
    }
    function noop() {
    }
    function nullTime() {
      return false;
    }
    function epochTime() {
      return Date.now();
    }
    function unixTime() {
      return Math.round(Date.now() / 1e3);
    }
    function isoTime() {
      return new Date(Date.now()).toISOString();
    }
    function pfGlobalThisOrFallback() {
      function defd(o) {
        return typeof o !== "undefined" && o;
      }
      try {
        if (typeof globalThis !== "undefined")
          return globalThis;
        Object.defineProperty(Object.prototype, "globalThis", {
          get: function() {
            delete Object.prototype.globalThis;
            return this.globalThis = this;
          },
          configurable: true
        });
        return globalThis;
      } catch (e) {
        return defd(self) || defd(window) || defd(this) || {};
      }
    }
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  config: () => config2,
  default: () => Obsidisaurus,
  logger: () => logger
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/markdownProcessor.ts
var readline = __toESM(require("readline"));
var stream = __toESM(require("stream"));

// config.ts
var config;
function setSettings(settings) {
  config = settings;
}

// src/markdownProcessor.ts
async function processMarkdown(processedFileName, sourceContent, assetJson) {
  const sourceStream = new stream.Readable();
  sourceStream.push(sourceContent);
  sourceStream.push(null);
  const rl = readline.createInterface({
    input: sourceStream,
    output: process.stdout,
    terminal: false
  });
  let transformedContent = "";
  let inAdmonition = false, inQuote = false;
  let admonition = { type: "", title: "", whitespaces: 0 };
  for await (const line of rl) {
    let processedLine = await convertObsidianLinks(line);
    processedLine = checkForAssets(processedLine, processedFileName, assetJson);
    processedLine = checkForLinks(processedLine);
    [processedLine, inAdmonition, inQuote, admonition] = convertAdmonition(processedLine, inAdmonition, inQuote, admonition);
    transformedContent += processedLine + "\n";
  }
  return transformedContent;
}
async function convertObsidianLinks(line) {
  const pattern = new RegExp(`!\\[\\[(${config.docusaurusAssetSubfolderName}/.*?)\\]\\]`);
  const match = line.match(pattern);
  if (match !== null) {
    const newPath = `![](${match[1]})`;
    return line.replace(match[0], newPath);
  } else {
    return line;
  }
}
var parseAdmonitionData = (line) => {
  var _a, _b, _c;
  const match = line.match(/^>\s*\[!(?<type>.*)](?<title>.*)?/);
  if (!match)
    return { type: "", title: "", whitespaces: 0 };
  return {
    type: ((_a = match.groups) == null ? void 0 : _a.type) || "",
    title: ((_c = (_b = match.groups) == null ? void 0 : _b.title) == null ? void 0 : _c.trim()) || "",
    whitespaces: line.indexOf("[") - line.indexOf(">")
  };
};
var convertAdmonition = (line, isInAdmonition, isInQuote, admonition) => {
  if (!isInAdmonition && !isInQuote) {
    admonition = parseAdmonitionData(line);
  }
  if (isInAdmonition) {
    if (line.trim() === "") {
      line = ":::\n";
      isInAdmonition = false;
    } else {
      line = line.slice(admonition.whitespaces);
    }
  } else if (isInQuote) {
    if (line.trim() === "") {
      line = ">\n> \u2014 " + admonition.title + "\n";
      isInQuote = false;
    }
  } else if (admonition.type) {
    if (admonition.type === "quote") {
      line = "";
      isInQuote = true;
    } else {
      isInAdmonition = true;
      line = ":::" + admonition.type;
      if (admonition.title) {
        line += " " + admonition.title;
      }
      line += "\n";
    }
  }
  return [line, isInAdmonition, isInQuote, admonition];
};
function checkForLinks(line) {
  const pattern = /\[([^\]]+)\]\(([^)]+)\)/;
  const match = line.match(pattern);
  if (match) {
    const url = match[2];
    if (url.includes("http")) {
      return line;
    } else {
      const urlParts = url.split("/");
      if (urlParts.length <= 1)
        return line;
      let mainFolder = urlParts[0];
      const isBlog = isBlogFolder(mainFolder);
      if (isBlog) {
        mainFolder = removeBlogSuffix(mainFolder);
        urlParts[0] = mainFolder;
      }
      const processedUrlParts = processUrlParts(urlParts, isBlog);
      const newUrl = "/" + processedUrlParts.join("/");
      return line.replace(url, newUrl);
    }
  }
  return line;
}
function processUrlParts(urlParts, isBlog) {
  urlParts = [...urlParts];
  const file = urlParts[urlParts.length - 1];
  let parentFolder = urlParts[urlParts.length - 2];
  if (parentFolder.endsWith("+")) {
    parentFolder = parentFolder.replace("+", "");
    urlParts.pop();
    urlParts[urlParts.length - 1] = isBlog ? parentFolder.split("-").join("/") : removeNumberPrefix(parentFolder);
  } else if (file.endsWith(".md")) {
    urlParts[urlParts.length - 1] = file.replace(".md", "");
  }
  if (isBlog) {
    urlParts[urlParts.length - 1] = urlParts[urlParts.length - 1].split("-").join("/");
  }
  if (!isBlog) {
    urlParts = urlParts.map((part) => removeNumberPrefix(part));
  }
  return urlParts;
}
function isBlogFolder(mainFolder) {
  return mainFolder === "blog" || mainFolder.endsWith("__blog");
}
function removeBlogSuffix(mainFolder) {
  return mainFolder.replace("__blog", "");
}
function removeNumberPrefix(str) {
  return str.replace(/^\d+[\.\-\)\s%20]*\s*/, "").trim();
}
function getOrCreateSize(sizes, size, processedFileName) {
  let existingSize = sizes.find((s) => s.size === size);
  if (!existingSize) {
    existingSize = {
      size,
      inDocuments: [processedFileName],
      newName: []
    };
    sizes.push(existingSize);
  } else if (!existingSize.inDocuments.includes(processedFileName)) {
    existingSize.inDocuments.push(processedFileName);
  }
  return existingSize;
}
function checkForAssets(line, processedFileName, assetJson) {
  const match = line.match(/!\[(?:\|(?<size>\d+(x\d+)?))?\]\((?<path>.*?)\)/);
  if (match && match.groups) {
    let { size, path: path3 } = match.groups;
    const fileNameWithExtension = path3.split("/").pop();
    let [fileName, fileExtension] = fileNameWithExtension.split(".");
    fileName = fileName.replace(/ /g, "_");
    fileName = fileName.replace(/%20/g, "_");
    if (!(size == null ? void 0 : size.trim())) {
      size = "standard";
    }
    let existingAsset = assetJson.find((item) => item.fileName === fileName);
    let existingSize;
    if (existingAsset) {
      existingSize = getOrCreateSize(existingAsset.sizes, size, processedFileName);
    } else {
      existingAsset = {
        fileName,
        //@ts-ignore
        originalFileName: fileNameWithExtension,
        fileExtension,
        dateModified: new Date().toISOString(),
        sourcePathRelative: path3,
        sizes: []
      };
      existingSize = getOrCreateSize(existingAsset.sizes, size, processedFileName);
      assetJson.push(existingAsset);
    }
    if (["jpg", "png", "webp", "jpeg", "bmp", "gif", "svg", "excalidraw"].includes(fileExtension)) {
      line = processImage(line, fileName, fileExtension, size, existingSize);
    } else {
      line = processAsset(line, fileName, fileExtension);
    }
  }
  return line;
}
function processImage(line, fileName, fileExtension, size, sizeObject) {
  var _a;
  const sizeSuffix = size === "standard" ? "" : `_${size}`;
  const extensionFormatMap = {
    "gif": `/assets/${fileName}${sizeSuffix}.${fileExtension}`,
    "svg": `/assets/${fileName}${sizeSuffix}.${fileExtension}`,
    //"svg": `/assets/${fileName}${sizeSuffix}.light.svg#light`,
    "excalidraw": `/assets/${fileName}${sizeSuffix}.excalidraw.light.svg#light`
  };
  let newPath = `/assets/${fileName}${sizeSuffix}.${config.convertedImageType}`;
  if (extensionFormatMap[fileExtension]) {
    newPath = extensionFormatMap[fileExtension];
    line = `![${fileName}](${newPath})`;
    if (fileExtension === "excalidraw") {
      const darkPath = newPath.replace(".light.svg#light", ".dark.svg#dark");
      line += `
![${fileName}](${darkPath})`;
    }
  } else {
    line = `![${fileName}](${newPath})`;
  }
  const newName = (_a = newPath.split("/").pop()) == null ? void 0 : _a.split("#")[0];
  if (newName && !sizeObject.newName.includes(newName)) {
    sizeObject.newName.push(newName);
  }
  return line;
}
function processAsset(line, fileName, fileExtension) {
  line = `[Download ${fileName}.${fileExtension}](${config.docusaurusAssetSubfolderName}/${fileName}.${fileExtension})`;
  return line;
}

// src/mainProcessor.ts
var import_obsidian = require("obsidian");
var fs = __toESM(require("fs"));
var path = __toESM(require("path"));
var import_util = __toESM(require("util"));
async function obsidiosaurusProcess(basePath) {
  const websitePath = path.join(basePath, "website");
  const vaultPath = path.join(basePath, "vault");
  const mainFolders = getMainfolders(vaultPath);
  mainFolders.forEach((folder) => processSingleFolder(folder, vaultPath));
  if (config.debug) {
    logger.info(
      "\u{1F4C1} Folder structure with Files: %s",
      JSON.stringify(mainFolders)
    );
  }
  const allInfo = mainFolders.flatMap(
    (folder) => folder.files.map(
      (file) => getSourceFileInfo(basePath, folder, file, vaultPath)
    )
  );
  const allSourceFilesInfo = allInfo.filter(
    (info) => info.type !== "assets"
  );
  const allSourceAssetsInfo = allInfo.filter(
    (info) => info.type === "assets"
  );
  let targetJson = await initializeJsonFile(
    path.join(basePath, "allFilesInfo.json")
  );
  let assetJson = await initializeJsonFile(
    path.join(basePath, "assetInfo.json")
  );
  targetJson = await checkFilesExistence(targetJson);
  const filesToDelete = await getFilesToDelete(
    allSourceFilesInfo,
    targetJson
  );
  await deleteFiles(filesToDelete, targetJson, basePath);
  await removeAssetReferences(filesToDelete, assetJson, websitePath);
  targetJson = await writeJsonToFile(
    path.join(basePath, "allFilesInfo.json"),
    targetJson
  );
  await writeJsonToFile(
    path.join(basePath, "allSourceAssetsInfo.json"),
    allSourceAssetsInfo
  );
  const filesToProcess = await compareSource(allSourceFilesInfo, targetJson);
  if (filesToProcess.length > 0) {
    new import_obsidian.Notice(`\u2699 Processing ${filesToProcess.length} Files`);
    const filesToProcessIndices = filesToProcess.map((file) => file.index);
    const filesToMarkdownProcess = allSourceFilesInfo.filter(
      (_, index) => filesToProcessIndices.includes(index)
    );
    await copyMarkdownFilesToTarget(
      filesToMarkdownProcess,
      basePath,
      targetJson,
      assetJson
    );
    await writeJsonToFile(
      path.join(basePath, "allFilesInfo.json"),
      targetJson
    );
  } else {
    new import_obsidian.Notice(`\u{1F4A4} Nothing to process`);
  }
  augmentPathForMacOS();
  const assetsToProcess = await getAssetsToProcess(assetJson, websitePath);
  new import_obsidian.Notice(`\u2699 Processing ${assetsToProcess.length} Assets`);
  if (assetsToProcess.length > 0) {
    await copyAssetFilesToTarget(
      vaultPath,
      websitePath,
      assetJson,
      assetsToProcess
    );
  }
  deleteUnusedFiles(targetJson, websitePath);
  logger.info("\u2705 Obsidiosaurus run successfully");
  new import_obsidian.Notice("\u2705 Obsidiosaurus run successfully");
  return true;
}
async function initializeJsonFile(filePath, defaultContent = "[]") {
  let jsonContent = [];
  try {
    jsonContent = JSON.parse(await fs.promises.readFile(filePath, "utf-8"));
  } catch (error) {
    if (error.code === "ENOENT") {
      await fs.promises.writeFile(filePath, defaultContent);
      console.log(`Created ${filePath}`);
    } else {
      console.error(`Error reading file: ${filePath}`, error);
    }
  }
  return jsonContent;
}
async function writeJsonToFile(filePath, content) {
  await fs.promises.writeFile(filePath, JSON.stringify(content, null, 2));
  return JSON.parse(await fs.promises.readFile(filePath, "utf-8"));
}
function augmentPathForMacOS() {
  const os = require("os");
  if (config.debug) {
    logger.info(`\u{1F5FA}\uFE0F Current Obsidian ENV PATH: ${process.env.PATH}`);
  }
  if (os.platform() === "darwin") {
    const homebrewPath = "/opt/homebrew/bin:/usr/local/bin/brew";
    if (!process.env.PATH.includes(homebrewPath)) {
      process.env.PATH = homebrewPath + ":" + process.env.PATH;
      if (config.debug) {
        logger.info(`\u{1F5FA}\uFE0F New ENV PATH: ${process.env.PATH}`);
      }
    }
  }
}
function getMainfolders(folderPath) {
  const folders = [];
  const absoluteFolderPath = path.resolve(folderPath);
  if (config.debug) {
    logger.info("\u{1F4C1} Processing path: %s", absoluteFolderPath);
  }
  const objects = fs.readdirSync(absoluteFolderPath);
  if (config.debug) {
    logger.info("\u{1F4C2} Found files: %o", objects);
  }
  objects.forEach((object) => {
    const filePath = path.join(absoluteFolderPath, object);
    const stats = fs.statSync(filePath);
    if (stats.isDirectory()) {
      let type;
      if (object.endsWith("__blog")) {
        type = "blogMulti";
      } else if (object.includes("blog")) {
        type = "blog";
      } else if (object.includes("docs")) {
        type = "docs";
      } else if (object.includes(config.obsidianAssetSubfolderName)) {
        type = "assets";
      } else {
        type = "ignore";
      }
      if (type !== "ignore" && type !== void 0) {
        const folderObject = {
          name: object,
          type,
          files: []
        };
        folders.push(folderObject);
      }
      if (config.debug) {
        logger.info("\u{1F50D} File: %s, Type: %s", object, type);
      }
    }
  });
  if (config.debug) {
    logger.info("\u{1F4E4} Returning folders: %o", folders);
  }
  return folders;
}
function searchFilesInFolder(directory) {
  let results = [];
  let skipFiles = ".DS_Store";
  const files = fs.readdirSync(directory);
  files.forEach((file) => {
    if (skipFiles.includes(file)) {
      if (config.debug) {
        logger.info(`\u23ED\uFE0F Skipped ${file}`);
      }
      return;
    }
    const filePath = path.join(directory, file);
    const stat = fs.statSync(filePath);
    if (stat && stat.isDirectory()) {
      results = results.concat(searchFilesInFolder(filePath));
    } else {
      results.push(filePath);
    }
  });
  return results;
}
function processSingleFolder(folder, basePath) {
  const dirPath = path.join(basePath, folder.name);
  const files = searchFilesInFolder(dirPath);
  folder.files = files;
  if (config.debug) {
    logger.info(
      "\u{1F4C4} Vault Files for %s: %s",
      folder.name,
      JSON.stringify(files)
    );
  }
}
async function deleteParentDirectories(filepath) {
  let dirPath = path.dirname(filepath);
  while (dirPath !== path.dirname(dirPath)) {
    try {
      await fs.promises.rmdir(dirPath);
      if (config.debug) {
        logger.info(`\u{1F9E8} Successfully deleted directory ${dirPath}`);
      }
    } catch (error) {
      if (error.code !== "ENOTEMPTY" && error.code !== "EEXIST" && error.code !== "EPERM") {
        logger.info(
          `\u274C Failed to delete directory ${dirPath}: ${error}`
        );
      }
      return;
    }
    dirPath = path.dirname(dirPath);
  }
}
async function ensureDirectoryExistence(filePath) {
  const dir = path.dirname(filePath);
  if (fs.existsSync(dir)) {
    return true;
  }
  await fs.promises.mkdir(dir, { recursive: true });
}
async function compareSource(sourceJson, targetJson) {
  const filesToProcess = [];
  sourceJson.forEach((sourceFile, i) => {
    const matchingTargetFile = targetJson.find(
      (file) => file.pathSourceRelative === sourceFile.pathSourceRelative
    );
    if (!matchingTargetFile) {
      filesToProcess.push({
        index: i,
        reason: "Does not exist in targetJson"
      });
      if (config.debug) {
        logger.info(
          "\u{1F4DD} File to process: %s",
          sourceFile.pathSourceRelative
        );
      }
    }
  });
  return filesToProcess;
}
function getSourceFileInfo(basePath, folder, filePath, vaultPath) {
  filePath = path.resolve(filePath);
  const stats = fs.statSync(filePath);
  const fileName = path.basename(filePath);
  const { fileNameClean, fileExtension, language } = sanitizeFileName(fileName);
  const pathSourceRelative = path.relative(vaultPath, filePath);
  let sourceFileInfo = {
    fileName,
    fileNameClean,
    fileExtension,
    language,
    mainFolder: folder.name,
    parentFolder: path.basename(path.dirname(filePath)),
    pathSourceAbsolute: filePath,
    pathSourceRelative,
    dateModified: stats.mtime,
    size: stats.size,
    type: folder.type
  };
  sourceFileInfo = getTargetPath(sourceFileInfo, basePath);
  return sourceFileInfo;
}
function sanitizeFileName(fileName) {
  const parsedPath = path.parse(fileName);
  const fileNameWithoutExtension = parsedPath.name;
  const fileExtension = parsedPath.ext;
  let fileNameClean = fileNameWithoutExtension;
  const languageMatch = fileNameClean.match(/__([a-z]{2})$/i);
  let language = null;
  if (languageMatch) {
    fileNameClean = fileNameClean.split("__")[0];
    language = languageMatch ? languageMatch[1] : null;
  }
  if (language === null) {
    if (config && config.mainLanguage) {
      language = config.mainLanguage;
    } else {
      const errorMessage = "\u274C Main language not defined in the configuration";
      logger.error(errorMessage);
      throw new Error(errorMessage);
    }
  }
  return { fileNameClean: fileNameClean.trim(), fileExtension, language };
}
function getTargetPath(sourceFileInfo, basePath) {
  const {
    type,
    language,
    pathSourceRelative,
    mainFolder,
    parentFolder,
    fileExtension
  } = sourceFileInfo;
  if (!type || !language || !pathSourceRelative || !parentFolder || !fileExtension || !mainFolder) {
    logger.error("\u{1F6A8} Required properties missing on sourceFileInfo");
    throw new Error("Missing required properties on sourceFileInfo");
  }
  const isMainLanguage = language === config.mainLanguage;
  const mainPathDict = {
    docs: isMainLanguage ? "" : path.join(
      "i18n",
      language,
      "docusaurus-plugin-content-docs",
      "current"
    ),
    blog: isMainLanguage ? "" : path.join("i18n", language, "docusaurus-plugin-content-blog"),
    blogMulti: isMainLanguage || !mainFolder ? "" : path.join(
      "i18n",
      language,
      `docusaurus-plugin-content-blog-${mainFolder}`
    ),
    assets: path.join("static", config.docusaurusAssetSubfolderName)
  };
  const mainPath = mainPathDict[type] || "";
  let finalPathSourceRelative = pathSourceRelative;
  if (parentFolder.endsWith("+")) {
    const pathParts = finalPathSourceRelative.split(path.sep);
    pathParts.pop();
    if (!isMainLanguage) {
      pathParts.shift();
    }
    if (pathParts.length > 0) {
      let lastPart = pathParts[pathParts.length - 1];
      if (lastPart.endsWith("+")) {
        lastPart = lastPart.slice(0, -1);
        pathParts[pathParts.length - 1] = lastPart;
      }
      finalPathSourceRelative = pathParts.join(path.sep) + fileExtension;
    }
  }
  finalPathSourceRelative = finalPathSourceRelative.replace(
    `__${language}`,
    ""
  );
  if (finalPathSourceRelative.endsWith(".yml.md")) {
    finalPathSourceRelative = finalPathSourceRelative.replace(
      ".yml.md",
      ".yml"
    );
  }
  sourceFileInfo.pathTargetRelative = path.join(
    mainPath,
    finalPathSourceRelative
  );
  sourceFileInfo.pathTargetAbsolute = path.join(
    basePath,
    config.docusaurusWebsiteDirectory,
    sourceFileInfo.pathTargetRelative
  );
  return sourceFileInfo;
}
async function getFilesToDelete(allSourceFilesInfo, targetJson) {
  const sourceJson = allSourceFilesInfo;
  const filesToDelete = [];
  targetJson.forEach((targetFile, i) => {
    const matchingSourceFile = sourceJson.find(
      (file) => file.pathSourceRelative === targetFile.pathSourceRelative
    );
    const targetDate = new Date(targetFile.dateModified);
    const sourceDate = (matchingSourceFile == null ? void 0 : matchingSourceFile.dateModified) ? new Date(matchingSourceFile.dateModified) : null;
    if (!matchingSourceFile) {
      filesToDelete.push({
        index: i,
        reason: "it does not exist in sourceJson",
        pathKey: targetFile.pathSourceRelative
      });
      if (config.debug) {
        logger.info(
          "\u{1F5D1}\uFE0F File to delete: %s",
          targetFile.pathSourceRelative
        );
      }
    } else if (sourceDate && targetDate.getTime() < sourceDate.getTime()) {
      filesToDelete.push({
        index: i,
        reason: `its last modification date ${targetDate} is older than the date in sourceJson ${sourceDate}`,
        pathKey: targetFile.pathSourceRelative
      });
      if (config.debug) {
        logger.info(
          "\u{1F504} File to update: %s, Target: %s Source: %s",
          targetFile.pathSourceRelative,
          targetDate,
          sourceDate
        );
      }
    }
  });
  return filesToDelete;
}
async function deleteFiles(filesToDelete, targetJson, basePath) {
  const errors = [];
  filesToDelete.sort((a, b) => b.index - a.index);
  for (const fileToDelete of filesToDelete) {
    const targetFile = targetJson[fileToDelete.index];
    try {
      await fs.promises.unlink(
        path.join(basePath, targetFile.pathTargetRelative)
      );
      if (config.debug) {
        logger.info(
          `\u2705 Successfully deleted file %s`,
          targetFile.pathTargetRelative
        );
      }
      await deleteParentDirectories(
        path.join(basePath, targetFile.pathTargetRelative)
      );
      targetJson.splice(fileToDelete.index, 1);
    } catch (error) {
      if (error.code !== "ENOENT") {
        logger.error(
          `\u274C Failed to delete file %s: %s`,
          targetFile.pathTargetRelative,
          error
        );
        errors.push(error);
        continue;
      }
      if (config.debug) {
        logger.info(
          `\u{1F5D1}\uFE0F File %s was not found, considered as deleted`,
          targetFile.pathTargetRelative
        );
      }
      targetJson.splice(fileToDelete.index, 1);
    }
  }
}
async function checkFilesExistence(targetJson) {
  const existentFiles = await Promise.all(
    targetJson.map(async (fileInfo) => {
      try {
        await fs.promises.access(fileInfo.pathTargetAbsolute);
        const stats = await fs.promises.stat(
          fileInfo.pathTargetAbsolute
        );
        fileInfo.dateModifiedTarget = stats.mtime;
        fileInfo.sizeTarget = stats.size;
        return fileInfo;
      } catch (err) {
        if (err.code !== "ENOENT") {
          throw err;
        }
        console.log(`File not fond: ${fileInfo.pathSourceRelative}`);
        return null;
      }
    })
  );
  const len = existentFiles.length;
  const files = existentFiles.filter((fileInfo) => fileInfo !== null);
  if (config.debug) {
    logger.info("Removed %i Files", len - files.length);
  }
  return files;
}
function deleteUnusedFiles(json, websitePath) {
  const targetDirectories = ["blog", "i18n", "docs"];
  const blogSuffix = "__blog";
  let filesFound = [];
  function exploreDirectory(directory) {
    const entries = fs.readdirSync(directory, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path.join(directory, entry.name);
      if (entry.isDirectory()) {
        exploreDirectory(fullPath);
      } else if (entry.isFile()) {
        filesFound.push(fullPath);
      }
    }
  }
  targetDirectories.forEach((dir) => {
    const dirPath = path.join(websitePath, dir);
    if (fs.existsSync(dirPath)) {
      exploreDirectory(dirPath);
    }
  });
  const allDirectories = fs.readdirSync(websitePath, { withFileTypes: true });
  const otherDirectories = allDirectories.filter(
    (dir) => dir.name.endsWith(blogSuffix)
  );
  otherDirectories.forEach((dir) => {
    const dirPath = path.join(websitePath, dir.name);
    exploreDirectory(dirPath);
  });
  filesFound.forEach(async (file) => {
    const fileIsUsed = json.some((j) => j.pathTargetAbsolute === file);
    if (!fileIsUsed) {
      await fs.promises.unlink(file);
      console.log(`Deleted unused file: ${file}`);
    }
  });
}
async function copyMarkdownFilesToTarget(files, basePath, targetJson, assetJson) {
  const results = [];
  const promises2 = files.map(async (file) => {
    const { pathTargetAbsolute, pathSourceAbsolute, pathSourceRelative } = file;
    if (pathTargetAbsolute && pathSourceAbsolute && pathSourceRelative) {
      await ensureDirectoryExistence(pathTargetAbsolute);
      const sourceContent = await fs.promises.readFile(
        pathSourceAbsolute,
        "utf-8"
      );
      const transformedContent = await processMarkdown(
        pathSourceRelative,
        sourceContent,
        assetJson
      );
      if (transformedContent) {
        await fs.promises.writeFile(
          pathTargetAbsolute,
          String(transformedContent)
        );
      }
      if (config.debug) {
        logger.info(
          `\u{1F4E4} Converted file from ${pathSourceAbsolute} to ${pathTargetAbsolute}`
        );
      }
    }
    results.push(file);
  });
  await Promise.all(promises2);
  targetJson.push(...results);
  await fs.promises.writeFile(
    path.join(basePath, "assetInfo.json"),
    JSON.stringify(assetJson, null, 2)
  );
}
async function removeAssetReferences(filesToDelete, assetJson, websitePath) {
  for (const fileToDelete of filesToDelete) {
    if (!fileToDelete.pathKey) {
      continue;
    }
    for (let assetIndex = assetJson.length - 1; assetIndex >= 0; assetIndex--) {
      const asset = assetJson[assetIndex];
      for (let sizeIndex = asset.sizes.length - 1; sizeIndex >= 0; sizeIndex--) {
        const size = asset.sizes[sizeIndex];
        const docIndex = size.inDocuments.indexOf(fileToDelete.pathKey);
        if (docIndex !== -1) {
          size.inDocuments.splice(docIndex, 1);
          if (config.debug) {
            logger.info(
              `\u{1F5D1} Removed filePath from inDocuments: ${fileToDelete.pathKey}`
            );
          }
          if (size.inDocuments.length === 0) {
            const assetToRemove = size.newName;
            await removeAssetFromTarget(
              assetToRemove,
              config.docusaurusAssetSubfolderName,
              websitePath
            );
            asset.sizes.splice(sizeIndex, 1);
            if (config.debug) {
              logger.info(
                `\u{1F525} Removed size from sizes: ${size.size}`
              );
            }
          }
        }
      }
      if (asset.sizes.length === 0) {
        assetJson.splice(assetIndex, 1);
        if (config.debug) {
          logger.info(
            `\u{1F4A5} Removed asset from assetJson: ${asset.fileName}`
          );
        }
      }
    }
  }
  return assetJson;
}
async function removeAssetFromTarget(assetToRemove, docusaurusAssetSubfolderName, websitePath) {
  for (const asset of assetToRemove) {
    const assetPath = path.join(
      websitePath,
      "static",
      docusaurusAssetSubfolderName,
      asset
    );
    try {
      await fs.promises.unlink(assetPath);
      if (config.debug) {
        logger.info(`\u{1F5D1} Removed asset: ${assetPath}`);
      }
    } catch (error) {
      if (config.debug) {
        logger.error(`\u274C Error removing asset: ${assetPath}`, error);
      }
    }
  }
}
var copyFile2 = import_util.default.promisify(fs.copyFile);
var mkdir2 = import_util.default.promisify(fs.mkdir);
async function copyAssetFilesToTarget(vaultPathPath, websitePath, assetJson, assetsToProcess) {
  const docusaurusAssetFolderPath = path.join(
    websitePath,
    "static",
    config.docusaurusAssetSubfolderName
  );
  await mkdir2(docusaurusAssetFolderPath, { recursive: true });
  for (const assetToProcess of assetsToProcess) {
    const asset = assetJson[assetToProcess.assetIndex];
    const size = asset.sizes[assetToProcess.sizeIndex];
    const originalFilePath = path.join(
      vaultPathPath,
      config.obsidianAssetSubfolderName,
      asset.originalFileName
    ).replace(/%20/g, " ");
    for (const newName of size.newName) {
      const newFilePath = path.join(docusaurusAssetFolderPath, newName);
      if (["jpg", "png", "webp", "jpeg", "bmp", "gif"].includes(
        asset.fileExtension
      )) {
        try {
          if (size.size === "standard" && asset.fileExtension === "gif") {
            await fs.copyFileSync(originalFilePath, newFilePath);
            if (config.debug) {
              logger.info(
                `Image copied from ${originalFilePath} to ${newFilePath}`
              );
            }
          } else {
            await resizeImage(
              originalFilePath,
              newFilePath,
              size.size
            );
            if (config.debug) {
              logger.info(
                `Image resized and copied from ${originalFilePath} to ${newFilePath}`
              );
            }
          }
        } catch (error) {
          if (config.debug) {
            logger.info(
              `Failed to resize image and copy from ${originalFilePath} to ${newFilePath}: ${error.message}`
            );
          }
        }
      } else if (asset.fileExtension == "svg") {
        await copySVG(originalFilePath, newFilePath);
      } else if ([asset.fileExtension].includes("excalidraw")) {
        await copyExcalidraw(originalFilePath, newFilePath);
      } else {
        try {
          await copyFile2(originalFilePath, newFilePath);
          if (config.debug) {
            logger.info(
              `File copied from ${originalFilePath} to ${newFilePath}`
            );
          }
        } catch (error) {
          if (config.debug) {
            logger.error(
              `Failed to copy file from ${originalFilePath} to ${newFilePath}: ${error.message}`
            );
          }
        }
      }
    }
  }
}
async function copySVG(originalFilePath, newFilePath) {
  await copyFile2(originalFilePath, newFilePath);
}
async function copyExcalidraw(originalFilePath, newFilePath) {
  const filePath = originalFilePath.replace(".md", "");
  const newDarkFilePath = newFilePath.replace(".light", ".dark");
  const darkFilePath = filePath + ".dark.svg";
  await copyFile2(darkFilePath, newDarkFilePath);
  const lightFilePath = filePath + ".light.svg";
  await copyFile2(lightFilePath, newFilePath);
}
var gm = require_gm().subClass({ imageMagick: "7+" });
async function resizeImage(originalFilePath, newFilePath, size) {
  const widthOriginal = await getImageWidth(originalFilePath);
  let width;
  let height;
  let auto = true;
  if (size === "standard") {
    width = Math.min(
      widthOriginal,
      parseInt(config.convertedImageMaxWidth)
    );
    height = "";
  } else {
    const dimensions = size.split("x");
    width = parseInt(dimensions[0]);
    height = dimensions.length > 1 ? parseInt(dimensions[1]) : "";
    if (height) {
      auto = false;
    }
  }
  let imageProcess = gm(originalFilePath).coalesce();
  if (auto) {
    imageProcess = imageProcess.resize(width, height);
  } else {
    imageProcess = imageProcess.resize(width, height, "!");
  }
  imageProcess.write(newFilePath, function(err) {
    if (err)
      logger.error(err);
  });
}
function getImageWidth(imagePath) {
  return new Promise((resolve2, reject) => {
    gm(imagePath).size((err, size) => {
      if (err) {
        logger.error("Error getting image width: ", err);
        reject(err);
      } else {
        resolve2(size.width);
      }
    });
  });
}
async function getAssetsToProcess(assetJson, websitePath) {
  const documents = [];
  for (const [assetIndex, asset] of assetJson.entries()) {
    for (const [sizeIndex, size] of asset.sizes.entries()) {
      for (const name of size.newName) {
        documents.push({ assetIndex, sizeIndex, path: name });
      }
    }
  }
  const assetsToProcess = documents.filter((document2) => {
    const fileExists = fs.existsSync(
      path.join(
        websitePath,
        "static",
        config.docusaurusAssetSubfolderName,
        document2.path
      )
    );
    if (!fileExists && config.debug) {
      logger.info(`File ${document2.path} does not exist.`);
    }
    return !fileExists;
  });
  return assetsToProcess;
}

// main.ts
var import_pino = __toESM(require_browser2());
var import_path = __toESM(require("path"));
var logger = (0, import_pino.default)();
var config2 = {
  obsidianVaultDirectory: "./vault",
  docusaurusWebsiteDirectory: "./website",
  obsidianAssetSubfolderName: "assets",
  docusaurusAssetSubfolderName: "assets",
  mainLanguage: "en",
  convertedImageType: "webp",
  convertedImageMaxWidth: "2500",
  debug: false,
  developer: false
};
var Obsidisaurus = class extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    if (this.settings.debug) {
      logger.info("\u{1F7E2} Obsidiosaurus Plugin loaded");
    }
    const ribbonIconEl = this.addRibbonIcon("file-up", "Obsidiosaurus", async (evt) => {
      try {
        logger.info("\u{1F680} Obsidiosaurus started");
        new import_obsidian2.Notice("\u{1F680} Obsidiosaurus started");
        if (this.app.vault.adapter instanceof import_obsidian2.FileSystemAdapter) {
          const basePath = import_path.default.dirname(this.app.vault.adapter.getBasePath());
          await obsidiosaurusProcess(basePath);
        }
      } catch (error) {
        if (this.settings.debug) {
          const errorMessage = `\u274C Obsidiosaurus crashed in function with the following error:
${error.stack}`;
          logger.error(errorMessage);
          new import_obsidian2.Notice(`\u274C Obsidiosaurus crashed. 
${errorMessage}`);
        } else {
          logger.error(`\u274C Obsidiosaurus crashed with error message: 
${error} `);
          new import_obsidian2.Notice("\u274C Obsidiosaurus crashed. \n Check log files for more info");
        }
      }
    });
    ribbonIconEl.addClass("my-plugin-ribbon-class");
    this.addSettingTab(new SettingTab(this.app, this));
  }
  onunload() {
    if (config2.debug) {
      logger.info("\u26AA Obsidiosaurus Plugin unloaded");
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, config2, await this.loadData());
    setSettings(this.settings);
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var SettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Directories" });
    new import_obsidian2.Setting(containerEl).setName("Docusaurus Directory").setDesc("Path to your docusaurus instance").addText((text) => text.setPlaceholder("Enter paths").setValue(this.plugin.settings.docusaurusWebsiteDirectory).onChange(async (value) => {
      this.plugin.settings.docusaurusWebsiteDirectory = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h1", { text: "Assets" });
    new import_obsidian2.Setting(containerEl).setName("Obsidian Asset Folder").setDesc("Name of Obsidian Asset Folder").addText((text) => text.setPlaceholder("Enter folders").setValue(this.plugin.settings.obsidianAssetSubfolderName).onChange(async (value) => {
      this.plugin.settings.obsidianAssetSubfolderName = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Docusaurus Asset Folder").setDesc("Name of Docusaurus Asset Folder").addText((text) => text.setPlaceholder("Enter folders").setValue(this.plugin.settings.docusaurusAssetSubfolderName).onChange(async (value) => {
      this.plugin.settings.docusaurusAssetSubfolderName = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Image Type").setDesc("Format in which to convert all images").addDropdown((dropdown) => dropdown.addOptions({
      "webp": "WebP"
    }).setValue(this.plugin.settings.convertedImageType).onChange(async (value) => {
      this.plugin.settings.convertedImageType = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Image Width").setDesc("Set the max width for the images in [px]").addText((number) => number.setPlaceholder("2500").setValue(this.plugin.settings.convertedImageMaxWidth).onChange(async (value) => {
      this.plugin.settings.convertedImageMaxWidth = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h1", { text: "Language" });
    new import_obsidian2.Setting(containerEl).setName("Main Language").setDesc("Your main language code to publish").addText((text) => text.setPlaceholder("Enter language code").setValue(this.plugin.settings.mainLanguage).onChange(async (value) => {
      this.plugin.settings.mainLanguage = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h1", { text: "Dev Options" });
    new import_obsidian2.Setting(containerEl).setName("Debug mode").setDesc("Better logging for debugging").addToggle((value) => {
      value.setValue(this.plugin.settings.debug).onChange((value2) => {
        this.plugin.settings.debug = value2;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Developer mode").setDesc("Only for plugin developers").addToggle((value) => {
      value.setValue(this.plugin.settings.debug).onChange((value2) => {
        this.plugin.settings.debug = value2;
        this.plugin.saveSettings();
      });
    });
  }
};
