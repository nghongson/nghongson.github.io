"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[5676],{60109:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var n=s(74848),i=s(28453);const o={},r=void 0,a={id:"architect/OAuth",title:"OAuth",description:"![[Pasted image 20240608100707.png]]",source:"@site/docs/architect/OAuth.md",sourceDirName:"architect",slug:"/architect/OAuth",permalink:"/docs/architect/OAuth",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"K.I.S.S Principle",permalink:"/docs/architect/KISS Principle"},next:{title:"SOLID",permalink:"/docs/architect/SOLID"}},c={},l=[];function u(e){const t={p:"p",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"![[Pasted image 20240608100707.png]]"}),"\n",(0,n.jsx)(t.p,{children:"OAuth allows different flows (processes), such as:"}),"\n",(0,n.jsx)(t.p,{children:"Authorization Code Flow \u2014 To be used for server-side applications, it acquires an authorization code to exchange for an access token, ensuring the client never exposes the tokens to the user-agent.\nImplicit Flow \u2014 Previously used for client-side applications like SPAs, it directly returns an access token upon authorization but lacks refresh tokens and is less recommended due to security issues. It is deprecated due to security weaknesses.\nResource Owner Password Credentials Flow \u2014 This flow allows the client to use the resource owner\u2019s username and password directly, which is suitable for highly trusted or legacy applications but is discouraged due to security risks.\nClient Credentials Flow \u2014 For server-to-server authentication, a client can use its credentials instead of impersonating a user to obtain an access token.\nRefresh Token Flow \u2014 When an access token expires, the client can obtain a new token using a refresh token without user interaction.\nDevice Code Flow \u2014 Designed for devices with limited input capabilities, it involves the user authorizing the device on a secondary device, following which the primary device gets the access token.\nExtension Flow \u2014 A catch-all for custom flows, allowing for adaptations of the OAuth 2.0 protocol to cater to specific needs or scenarios not covered by other predefined flows.\nUsually, use cases for OAuth 2.0 usage are:"}),"\n",(0,n.jsx)(t.p,{children:"Third-Party Access \u2014 Users can grant third-party applications limited access to their resources without sharing their credentials, like allowing a photo printing service access to photos stored in a cloud service.\nFor example, A user allows a scheduling app to access their Google Calendar to automatically set up meetings without sharing their Google credentials."}),"\n",(0,n.jsx)(t.p,{children:"Single Sign-On (SSO) \u2014 It facilitates Single Sign-On (SSO), where users can log in to multiple services using a single ID, streamlining the authentication process across platforms and services."})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(u,{...e})}):u(e)}},28453:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>a});var n=s(96540);const i={},o=n.createContext(i);function r(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);