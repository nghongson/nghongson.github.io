"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[497],{7682:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var i=t(4848),r=t(8453);const o={},s=void 0,a={id:"golang/SOLID Golang",title:"SOLID Golang",description:"Open / Closed Principle",source:"@site/docs/golang/SOLID Golang.md",sourceDirName:"golang",slug:"/golang/SOLID Golang",permalink:"/docs/golang/SOLID Golang",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"GoFiber",permalink:"/docs/golang/GoFiber/"},next:{title:"Learn Kafka - Event streaming platform",permalink:"/docs/microservices/Kafka/"}},c={},l=[{value:"Liskov Substitution Principle",id:"Liskov-Substitution-Principle",level:2},{value:"Instead, substitution is the purview of Go\u2019s <code>interfaces</code>.",id:"Instead-substitution-is-the-purview-of-Gos-interfaces",level:4},{value:"Interface Segregation Principle",id:"Interface-Segregation-Principle",level:2},{value:"Dependency Inversion Principle",id:"Dependency-Inversion-Principle",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h4:"h4",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Open / Closed Principle"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'package main\n\ntype A struct {\n        year int\n}\n\nfunc (a A) Greet() { fmt.Println("Hello GolangUK", a.year) }\n\ntype B struct {\n        A\n}\n\nfunc (b B) Greet() { fmt.Println("Welcome to GolangUK", b.year) }\n\nfunc main() {\n        var a A\n        a.year = 2016\n        var b B\n        b.year = 2016\n        a.Greet() // Hello GolangUK 2016\n        b.Greet() // Welcome to GolangUK 2016\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"Liskov-Substitution-Principle",children:"Liskov Substitution Principle"}),"\n",(0,i.jsx)(n.p,{children:"The Liskov substitution principle states, roughly, that two types are substitutable if they exhibit behaviour such that the caller is unable to tell the difference.\nGo does not have classes, or inheritance, so substitution cannot be implemented in terms of an abstract class hierarchy."}),"\n",(0,i.jsxs)(n.h4,{id:"Instead-substitution-is-the-purview-of-Gos-interfaces",children:["Instead, substitution is the purview of Go\u2019s ",(0,i.jsx)(n.code,{children:"interfaces"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"In Go, types are not required to nominate that they implement a particular interface, instead any type implements an interface simply provided it has methods whose signature matches the interface declaration."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"type Reader interface {\n        // Read reads up to len(buf) bytes into buf.\n        Read(buf []byte) (n int, err error)\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"Interface-Segregation-Principle",children:"Interface Segregation Principle"}),"\n",(0,i.jsx)(n.p,{children:'The fourth principle is the interface segregation principle,\n"Clients should not be forced to depend on methods they do not use."'}),"\n",(0,i.jsx)(n.p,{children:"In Go, the application of the interface segregation principle can refer to a process of isolating the behaviour required for a function to do its job."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// Save writes the contents of doc to the file f.\nfunc Save(f *os.File, doc *Document) error\n"})}),"\n",(0,i.jsx)(n.h2,{id:"Dependency-Inversion-Principle",children:"Dependency Inversion Principle"}),"\n",(0,i.jsx)(n.p,{children:"the final SOLID principle is the dependency inversion principle, which states:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"High-level modules should not depend on low-level modules. Both should depend on abstractions.\nAbstractions should not depend on details. Details should depend on abstractions.\n"})}),"\n",(0,i.jsx)(n.p,{children:"The context of Go, is the structure of your import graph.\nIn Go, your import graph must be acyclic. A failure to respect this acyclic requirement is grounds for a compilation failure, but more gravely represents a serious error in design."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://dave.cheney.net/2016/08/20/solid-go-design",children:"Solid Golang design"})})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var i=t(6540);const r={},o=i.createContext(r);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);