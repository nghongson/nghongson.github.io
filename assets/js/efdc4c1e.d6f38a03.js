"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[5676],{60109:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var s=i(74848),n=i(28453);const o={},r="OAuth",a={id:"architect/OAuth",title:"OAuth",description:"OAuth allows different flows (processes), such as:",source:"@site/docs/architect/OAuth.md",sourceDirName:"architect",slug:"/architect/OAuth",permalink:"/docs/architect/OAuth",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"K.I.S.S Principle",permalink:"/docs/architect/KISS Principle"},next:{title:"SOLID",permalink:"/docs/architect/SOLID"}},c={},l=[{value:"Third-Party Access",id:"Third-Party-Access",level:2},{value:"Single Sign-On (SSO)",id:"Single-Sign-On-SSO",level:2},{value:"Mobile Applications",id:"Mobile-Applications",level:2}];function h(e){const t={h1:"h1",h2:"h2",img:"img",p:"p",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"OAuth",children:"OAuth"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{src:"https://nghongson.github.io/media/Pasted%20image%2020240608100707.png",alt:""})}),"\n",(0,s.jsxs)(t.p,{children:["OAuth allows different flows (processes), such as:\n",(0,s.jsx)(t.img,{src:"https://nghongson.github.io/media/Pasted%20image%2020240608164537.png",alt:""}),"\nAuthorization Code Flow \u2014 To be used for server-side applications, it acquires an authorization code to exchange for an access token, ensuring the client never exposes the tokens to the user-agent.\nImplicit Flow \u2014 Previously used for client-side applications like SPAs, it directly returns an access token upon authorization but lacks refresh tokens and is less recommended due to security issues. It is deprecated due to security weaknesses.\nResource Owner Password Credentials Flow \u2014 This flow allows the client to use the resource owner\u2019s username and password directly, which is suitable for highly trusted or legacy applications but is discouraged due to security risks.\nClient Credentials Flow \u2014 For server-to-server authentication, a client can use its credentials instead of impersonating a user to obtain an access token.\nRefresh Token Flow \u2014 When an access token expires, the client can obtain a new token using a refresh token without user interaction.\nDevice Code Flow \u2014 Designed for devices with limited input capabilities, it involves the user authorizing the device on a secondary device, following which the primary device gets the access token.\nExtension Flow \u2014 A catch-all for custom flows, allowing for adaptations of the OAuth 2.0 protocol to cater to specific needs or scenarios not covered by other predefined flows.\nUsually, use cases for OAuth 2.0 usage are:"]}),"\n",(0,s.jsx)(t.h2,{id:"Third-Party-Access",children:"Third-Party Access"}),"\n",(0,s.jsx)(t.p,{children:"\u2014 Users can grant third-party applications limited access to their resources without sharing their credentials, like allowing a photo printing service access to photos stored in a cloud service.\nFor example, A user allows a scheduling app to access their Google Calendar to automatically set up meetings without sharing their Google credentials."}),"\n",(0,s.jsx)(t.h2,{id:"Single-Sign-On-SSO",children:"Single Sign-On (SSO)"}),"\n",(0,s.jsx)(t.p,{children:"\u2014 It facilitates Single Sign-On (SSO), where users can log in to multiple services using a single ID, streamlining the authentication process across platforms and services."}),"\n",(0,s.jsx)(t.p,{children:"For example, An employee logs into their corporate network and can access different departmental applications like email, HR system, and project management tool without logging in again."}),"\n",(0,s.jsx)(t.h2,{id:"Mobile-Applications",children:"Mobile Applications"}),"\n",(0,s.jsx)(t.p,{children:"\u2014 OAuth 2.0 provides a framework for mobile apps to obtain the necessary tokens for accessing protected resources, ensuring secure operations.\nFor example, A user downloads a fitness app which, upon authorization via OAuth 2.0, accesses their Spotify playlists to play music during workouts without requiring separate logins."}),"\n",(0,s.jsx)(t.p,{children:"This approach has some cons, too. Implementing OAuth 2.0 can be complex, especially for developers unfamiliar with its concepts and flows. While OAuth 2.0 is designed for authorization, it\u2019s sometimes mistaken for an authentication protocol, which it\u2019s not. This misconception can lead to improper implementations and potential security risks. Also, the specification leaves room for interpretation, leading to inconsistent implementations across different service providers, which can cause interoperability issues."})]})}function u(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453:(e,t,i)=>{i.d(t,{R:()=>r,x:()=>a});var s=i(96540);const n={},o=s.createContext(n);function r(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);