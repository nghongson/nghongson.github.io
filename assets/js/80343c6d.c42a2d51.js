"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7430],{74411:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var t=i(74848),r=i(28453);const s={},a="SOLID in Nodejs",o={id:"nodejs/SOLID",title:"SOLID in Nodejs",description:"Thank SamehEtman - SOLID Principles",source:"@site/docs/nodejs/SOLID.md",sourceDirName:"nodejs",slug:"/nodejs/SOLID",permalink:"/docs/nodejs/SOLID",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Profiling Node.js Applications",permalink:"/docs/nodejs/Profiling Node.js Applications"},next:{title:"Understanding Streams in Node.js",permalink:"/docs/nodejs/Streams"}},l={},c=[{value:"Single Responsibility Principle",id:"Single-Responsibility-Principle",level:2},{value:"Problem statement",id:"Problem-statement",level:3},{value:"Abstraction",id:"Abstraction",level:3},{value:"Bad Approach",id:"Bad-Approach",level:3},{value:"Better Approach",id:"Better-Approach",level:3},{value:"Open Closed Principle",id:"Open-Closed-Principle",level:2},{value:"Liskov Substitution principle",id:"Liskov-Substitution-principle",level:2},{value:"Interface segregation principle",id:"Interface-segregation-principle",level:2},{value:"Dependency Inversion Principle",id:"Dependency-Inversion-Principle",level:2},{value:"Inversion of control (IoC):",id:"Inversion-of-control-IoC",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"SOLID-in-Nodejs",children:"SOLID in Nodejs"}),"\n",(0,t.jsxs)(n.p,{children:["Thank ",(0,t.jsx)(n.a,{href:"https://github.com/SamehEtman/SOLID-Principles-JS/blob/master/ReadMe.md",children:"SamehEtman - SOLID Principles"})]}),"\n",(0,t.jsx)(n.h2,{id:"Single-Responsibility-Principle",children:"Single Responsibility Principle"}),"\n",(0,t.jsx)(n.p,{children:"Every module, class or function should have only one reason to change."}),"\n",(0,t.jsx)(n.h3,{id:"Problem-statement",children:"Problem statement"}),"\n",(0,t.jsx)(n.p,{children:"Say we need to make class Journal and we need to have the ability to add or remove journals to it , then we need a way or a method to write and read the content of this journal to the hard disk."}),"\n",(0,t.jsx)(n.h3,{id:"Abstraction",children:"Abstraction"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Make a journal class"}),"\n",(0,t.jsx)(n.li,{children:"Make addEntry and removeEntry methods"}),"\n",(0,t.jsx)(n.li,{children:"Write and Read from the hard disk"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"Bad-Approach",children:"Bad Approach"}),"\n",(0,t.jsx)(n.p,{children:"This looks like a small problem we will start by making a class Journal To make the basic features of adding and removing journals"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"class Journal\n{\n  constructor() {\n    this.entries = {};\n  }\n\n  addEntry(text) {\n    let c = ++Journal.count; // count of journals\n    let entry = `${c}: ${text}`;\n    this.entries[c] = entry;\n    return c;\n  }\n\n  removeEntry(index) {\n    delete this.entries[index];\n  }\n\n  toString() {\n    return Object.values(this.entries).join('\\n');\n  }\n\n}\nJournal.count = 0;\n"})}),"\n",(0,t.jsx)(n.p,{children:"So far so good let's move to the second feature where we add a read and write method to the hard disk Note : Reading and Writing to streams are only applicable on NodeJs"}),"\n",(0,t.jsx)(n.p,{children:"We will require the fs module and add the methods of writing and reading the journal entries"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"onst fs = require('fs');\n\nclass Journal {\n  constructor() {\n    this.entries = {};\n  }\n\n  addEntry(text) {\n    let c = ++Journal.count;\n    let entry = `${c}: ${text}`;\n    this.entries[c] = entry;\n    return c;\n  }\n  removeEntry(index) {\n    delete this.entries[index];\n  }\n  toString() {\n    return Object.values(this.entries).join('\\n');\n  }\n  \n  save(filename)\n  {\n    fs.writeFileSync(filename, this.toString());\n  }\n  load(path)\n  {\n    // code to read from a path\n  }\n  \n}\nJournal.count = 0;\n"})}),"\n",(0,t.jsx)(n.p,{children:"Huh that seemed easy but what if we needed to add another method of loading data such as loading form an api what if we wanted to add some preprocessing to the data before saving as you can see this class Journal is experiencing an Anti pattern know as Class Explosion which is a bad thing."}),"\n",(0,t.jsx)(n.h3,{id:"Better-Approach",children:"Better Approach"}),"\n",(0,t.jsx)(n.p,{children:"what we are trying to make it here is to prevent our Journal class from having multible responsiblities and make the code more flexible to use First , we will remove the save part from out Journal class making it only responsible for entries managment. Then , we make a new Class to handle the writing to the disk part we will call it WritingManager"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"class Journal {\n  constructor() {\n    this.entries = {};\n  }\n\n  addEntry(text) {\n    let c = ++Journal.count;\n    let entry = `${c}: ${text}`;\n    this.entries[c] = entry;\n    return c;\n  }\n\n  removeEntry(index) {\n    delete this.entries[index];\n  }\n\n  toString() {\n    return Object.values(this.entries).join('\\n');\n  }\n}\nJournal.count = 0;\n\nclass WritingManager {\n\n  saveToFile(journal, filename) {\n    fs.writeFileSync(filename, journal.toString());\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"Open-Closed-Principle",children:"Open Closed Principle"}),"\n",(0,t.jsx)(n.p,{children:"The Open/Closed Principle emphasizes that classes should be open for extension but closed for modification."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"interface Shape {\n    area(): number;\n}\nclass Rectangle implements Shape {\n    public width: number;\n    public height: number;\n    public area() {\n        return this.width * this.height;\n    }\n}\nclass Circle implements Shape {\n    public radius: number;\n    public area() {\n        return this.radius * this.radius * Math.PI;\n    }\n}\nfunction getArea(shapes: Shape[]) {\n    return shapes.reduce(\n        (previous, current) => previous + current.area(),\n        0\n    );\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"Liskov-Substitution-principle",children:"Liskov Substitution principle"}),"\n",(0,t.jsx)(n.p,{children:"The Liskov Substitution Principle states that objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"interface Shape {\n    area(): number;\n}\n\nclass Rectangle implements Shape {\n    public width: number;\n    public height: number;\n    public area() {\n        return this.width * this.height;\n    }\n}\n\nclass Square implements Shape {\n\n  public width: number;\n  \n  area() {\n    return this.side * this.side;\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"Interface-segregation-principle",children:"Interface segregation principle"}),"\n",(0,t.jsx)(n.p,{children:"Interface Segregation Principle suggests that a class should not be forced to implement interfaces it doesn't use"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"interface Shape {\n    area(): number;\n}\ninterface Serializable {\n    serialize(): string;\n}\nclass Rectangle implements RectangleInterface, Shape {\n    public width: number;\n    public height: number;\n    public area() {\n        return this.width * this.height;\n    }\n}\nclass RectangleDTO implements RectangleInterface, Serializable {\n    public width: number;\n    public height: number;\n    public serialize() {\n        return JSON.stringify(this);\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"Dependency-Inversion-Principle",children:"Dependency Inversion Principle"}),"\n",(0,t.jsx)(n.p,{children:"High level modules should not depend on low level modules; both should depend on abstractions."}),"\n",(0,t.jsx)(n.h2,{id:"Inversion-of-control-IoC",children:"Inversion of control (IoC):"}),"\n",(0,t.jsx)(n.p,{children:"IoC is a software engineering design principle that transfers control of an application's flow to a different part of the application.\nIoC can improve a program's\nPluggability, Testability, Usability, Loose coupling, Modularity, and Extensibility."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var t=i(96540);const r={},s=t.createContext(r);function a(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);