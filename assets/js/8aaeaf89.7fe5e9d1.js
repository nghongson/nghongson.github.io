"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4640],{62076:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>a,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>c,toc:()=>l});var t=o(74848),r=o(28453);const s={},i="Asynchronous programming",c={id:"architect/Asynchronous",title:"Asynchronous programming",description:"Asynchronous programming is a crucial technique for developing high-performance and flexible applications. It allows us to write non-blocking and efficient code that can handle concurrent requests and improve the performance of our application.",source:"@site/docs/architect/Asynchronous.md",sourceDirName:"architect",slug:"/architect/Asynchronous",permalink:"/docs/architect/Asynchronous",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"The Twelve Factors",permalink:"/docs/architect/12factors"},next:{title:"Background Process",permalink:"/docs/architect/Background Process"}},a={},l=[{value:"Synchronous",id:"Synchronous",level:3},{value:"Asynchronous",id:"Asynchronous",level:3}];function h(n){const e={code:"code",h1:"h1",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h1,{id:"Asynchronous-programming",children:"Asynchronous programming"}),"\n",(0,t.jsx)(e.p,{children:"Asynchronous programming is a crucial technique for developing high-performance and flexible applications. It allows us to write non-blocking and efficient code that can handle concurrent requests and improve the performance of our application."}),"\n",(0,t.jsx)(e.p,{children:"In the asynchronous approach, tasks are executed independently and concurrently. This means that the program doesn\u2019t wait for a task to complete before moving on to the next one."}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:"https://nghongson.github.io/media/Pasted%20image%2020240605112428.png",alt:""})}),"\n",(0,t.jsx)(e.h3,{id:"Synchronous",children:"Synchronous"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Pros: Easier to reason about, deterministic execution order, less complex error handling."}),"\n",(0,t.jsx)(e.li,{children:"Cons: Slower for long-running tasks, potentially slower overall execution time for multiple tasks."}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"Asynchronous",children:"Asynchronous"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Pros: Faster for concurrent tasks, better performance, ideal for parallel processing."}),"\n",(0,t.jsx)(e.li,{children:"Cons: More complex error handling, potential race conditions if not managed properly."}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"Golang:\nGolang is achieved using Goroutines, which are lightweight threads managed by the Go runtime."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-go",children:'package main\n\nimport (\n  "fmt"\n  "time"\n)\nfunc task1() {\n  time.Sleep(3 * time.Second)\n  fmt.Println("Task 1 completed.")\n}\n\nfunc task2() {\n  time.Sleep(2 * time.Second)\n  fmt.Println("Task 2 completed.")\n}\n\nfunc main() {\n  fmt.Println("Asynchronous Approach")\n  start := time.Now()\n  go task1()\n  go task2()\n\n  // Introduce a small sleep to allow Goroutines to execute\n  time.Sleep(4 * time.Second)\n  elapsed := time.Since(start)\n  fmt.Printf("Total execution time: %s\\n", elapsed)\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"Nodejs"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript"})})]})}function u(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(h,{...n})}):h(n)}},28453:(n,e,o)=>{o.d(e,{R:()=>i,x:()=>c});var t=o(96540);const r={},s=t.createContext(r);function i(n){const e=t.useContext(s);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:i(n.components),t.createElement(s.Provider,{value:e},n.children)}}}]);