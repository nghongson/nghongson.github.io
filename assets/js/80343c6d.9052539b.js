"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7430],{74411:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>d});var i=t(74848),r=t(28453);const o={},s="SOLID in Nodejs",a={id:"nodejs/SOLID",title:"SOLID in Nodejs",description:"Thank SamehEtman - SOLID Principles",source:"@site/docs/nodejs/SOLID.md",sourceDirName:"nodejs",slug:"/nodejs/SOLID",permalink:"/docs/nodejs/SOLID",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Profiling Node.js Applications",permalink:"/docs/nodejs/Profiling Node.js Applications"},next:{title:"Streaming",permalink:"/docs/nodejs/Streaming"}},l={},d=[{value:"Single Responsibility Principle",id:"Single-Responsibility-Principle",level:2},{value:"Problem statement",id:"Problem-statement",level:3},{value:"Abstraction",id:"Abstraction",level:3},{value:"Bad Approach",id:"Bad-Approach",level:3},{value:"Better Approach",id:"Better-Approach",level:3},{value:"Open Closed Principle",id:"Open-Closed-Principle",level:2},{value:"Liskov Substitution principle",id:"Liskov-Substitution-principle",level:2},{value:"Interface segregation principle",id:"Interface-segregation-principle",level:2},{value:"Dependency Inversion Principle",id:"Dependency-Inversion-Principle",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"SOLID-in-Nodejs",children:"SOLID in Nodejs"}),"\n",(0,i.jsxs)(n.p,{children:["Thank ",(0,i.jsx)(n.a,{href:"https://github.com/SamehEtman/SOLID-Principles-JS/blob/master/ReadMe.md",children:"SamehEtman - SOLID Principles"})]}),"\n",(0,i.jsx)(n.h2,{id:"Single-Responsibility-Principle",children:"Single Responsibility Principle"}),"\n",(0,i.jsx)(n.p,{children:"Every module, class or function should have only one reason to change."}),"\n",(0,i.jsx)(n.h3,{id:"Problem-statement",children:"Problem statement"}),"\n",(0,i.jsx)(n.p,{children:"Say we need to make class Journal and we need to have the ability to add or remove journals to it , then we need a way or a method to write and read the content of this journal to the hard disk."}),"\n",(0,i.jsx)(n.h3,{id:"Abstraction",children:"Abstraction"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Make a journal class"}),"\n",(0,i.jsx)(n.li,{children:"Make addEntry and removeEntry methods"}),"\n",(0,i.jsx)(n.li,{children:"Write and Read from the hard disk"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"Bad-Approach",children:"Bad Approach"}),"\n",(0,i.jsx)(n.p,{children:"This looks like a small problem we will start by making a class Journal To make the basic features of adding and removing journals"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"class Journal\n{\n  constructor() {\n    this.entries = {};\n  }\n\n  addEntry(text) {\n    let c = ++Journal.count; // count of journals\n    let entry = `${c}: ${text}`;\n    this.entries[c] = entry;\n    return c;\n  }\n\n  removeEntry(index) {\n    delete this.entries[index];\n  }\n\n  toString() {\n    return Object.values(this.entries).join('\\n');\n  }\n\n}\nJournal.count = 0;\n"})}),"\n",(0,i.jsx)(n.p,{children:"So far so good let's move to the second feature where we add a read and write method to the hard disk Note : Reading and Writing to streams are only applicable on NodeJs"}),"\n",(0,i.jsx)(n.p,{children:"We will require the fs module and add the methods of writing and reading the journal entries"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"onst fs = require('fs');\n\nclass Journal {\n  constructor() {\n    this.entries = {};\n  }\n\n  addEntry(text) {\n    let c = ++Journal.count;\n    let entry = `${c}: ${text}`;\n    this.entries[c] = entry;\n    return c;\n  }\n  removeEntry(index) {\n    delete this.entries[index];\n  }\n  toString() {\n    return Object.values(this.entries).join('\\n');\n  }\n  \n  save(filename)\n  {\n    fs.writeFileSync(filename, this.toString());\n  }\n  load(path)\n  {\n    // code to read from a path\n  }\n  \n}\nJournal.count = 0;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Huh that seemed easy but what if we needed to add another method of loading data such as loading form an api what if we wanted to add some preprocessing to the data before saving as you can see this class Journal is experiencing an Anti pattern know as Class Explosion which is a bad thing."}),"\n",(0,i.jsx)(n.h3,{id:"Better-Approach",children:"Better Approach"}),"\n",(0,i.jsx)(n.p,{children:"what we are trying to make it here is to prevent our Journal class from having multible responsiblities and make the code more flexible to use First , we will remove the save part from out Journal class making it only responsible for entries managment. Then , we make a new Class to handle the writing to the disk part we will call it WritingManager"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"class Journal {\n  constructor() {\n    this.entries = {};\n  }\n\n  addEntry(text) {\n    let c = ++Journal.count;\n    let entry = `${c}: ${text}`;\n    this.entries[c] = entry;\n    return c;\n  }\n\n  removeEntry(index) {\n    delete this.entries[index];\n  }\n\n  toString() {\n    return Object.values(this.entries).join('\\n');\n  }\n}\nJournal.count = 0;\n\nclass WritingManager {\n\n  saveToFile(journal, filename) {\n    fs.writeFileSync(filename, journal.toString());\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"Open-Closed-Principle",children:"Open Closed Principle"}),"\n",(0,i.jsx)(n.p,{children:"Software entities should be open for extension, but closed for modification."}),"\n",(0,i.jsx)(n.h2,{id:"Liskov-Substitution-principle",children:"Liskov Substitution principle"}),"\n",(0,i.jsx)(n.p,{children:"Objects of a superclass shall be replaceable with objects of its subclasses without breaking the application."}),"\n",(0,i.jsx)(n.h2,{id:"Interface-segregation-principle",children:"Interface segregation principle"}),"\n",(0,i.jsx)(n.h2,{id:"Dependency-Inversion-Principle",children:"Dependency Inversion Principle"}),"\n",(0,i.jsx)(n.p,{children:"High level modules should not depend on low level modules; both should depend on abstractions."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var i=t(96540);const r={},o=i.createContext(r);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);